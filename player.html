<!DOCTYPE html>
<html>
<head>
    <title>Three.js Avatar with Neck and Hair - Fixed</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

        // Szene, Kamera, Renderer und Licht (unverändert)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(light);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 20, 10);
        scene.add(directionalLight);

        // Materialien
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3366cc, metalness: 0.1, roughness: 0.7 });
        const handFootMaterial = new THREE.MeshStandardMaterial({ color: 0x99ccff, metalness: 0.1, roughness: 0.6 });
        const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });

        // Avatar Gruppe
        const avatar = new THREE.Group();
        scene.add(avatar);
        camera.lookAt(avatar.position);
        
        // Körperaufbau
        const pelvisGeom = new THREE.CylinderGeometry(0.3, 0.45, 0.5, 16);
        const pelvis = new THREE.Mesh(pelvisGeom, bodyMaterial);
        avatar.add(pelvis);

        const chestGeom = new THREE.CylinderGeometry(0.6, 0.35, 1.2, 16);
        const chest = new THREE.Mesh(chestGeom, bodyMaterial);
        chest.position.y = 0.85;
        avatar.add(chest);

        const neckGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.3, 16);
        const neck = new THREE.Mesh(neckGeom, bodyMaterial);
        neck.position.y = chest.position.y + 0.75;
        avatar.add(neck);

        const headGeom = new THREE.SphereGeometry(0.4, 32, 16);
        const head = new THREE.Mesh(headGeom, bodyMaterial);
        head.position.y = neck.position.y + 0.3;
        head.scale.y = 1.1;
        avatar.add(head);

        // Frisur Gruppe
        const hairGroup = new THREE.Group();
        head.add(hairGroup); 

        // Frisur 1: Stachel-Look 
        // const spikeGeom = new THREE.ConeGeometry(0.12, 0.5, 8); // Etwas breiter und höher

        // const spike1 = new THREE.Mesh(spikeGeom, hairMaterial);
        // spike1.position.y = 0.5; // Setzt den Kegel genau auf die Oberseite des Kopfes (Radius 0.4)
        // spike1.scale.set(0.9, 0.4, 0.9); // Skaliert den Kegel etwas kleiner
        // hairGroup.add(spike1);
        
        // const spike2 = new THREE.Mesh(spikeGeom, hairMaterial);
        // spike2.position.set(0.25, 0.3, 0); // Weiter nach außen und oben verschoben
        // spike2.scale.set(0.9, 0.9, 0.9);
        // spike2.rotation.z = -Math.PI / 5; // Rotiert den Kegel, sodass er von der Kopfform weg zeigt
        // hairGroup.add(spike2);

        // const spike3 = new THREE.Mesh(spikeGeom, hairMaterial);
        // spike3.position.set(-0.25, 0.3, 0); // Auf die andere Seite verschoben
        // spike3.scale.set(0.9, 0.9, 0.9);
        // spike3.rotation.z = Math.PI / 5; // In die entgegengesetzte Richtung gedreht
        // hairGroup.add(spike3);

        // // Frisur 2: Glatze
        // const baldHeadGeom = new THREE.SphereGeometry(0.4, 32, 16);
        // const baldHead = new THREE.Mesh(baldHeadGeom, hairMaterial);
        // baldHead.position.y = neck.position.y + 0.35;
        // baldHead.scale.y = 1.3;
        // baldHead.rotation.x = Math.PI / 2; // Dreht die Glatze, damit sie auf dem Kopf sitzt
        // // baldHead.visible = false; // Standardmäßig unsichtbar
        // // colors
        // baldHead.material.color.set(0x222200); // Setzt die Farbe der Glatze
        // baldHead.material.roughness = 0.8; // Setzt die Rauheit
        // baldHead.material.metalness = 0.1; // Setzt die Metallizität
        // baldHead.material.side = THREE.DoubleSide; // Macht die Glatze doppelseitig
        // avatar.add(baldHead);   

        // // Frisur 3: Hut
        const hatGeom = new THREE.CylinderGeometry(0.3, 0.4, .5, 10);
        const hat = new THREE.Mesh(hatGeom, hairMaterial);
        hat.position.y = neck.position.y + 0.45;
        hat.scale.y = 1.5; // Skaliert den Hut 
        hat.rotation.x = 9.6; // Dreht den Hut, damit er auf dem Kopf sitzt
        hat.material.color.set(0x663300); // Setzt die Farbe des Hutes
        hat.material.roughness = 0.8; // Setzt die Rauheit des Hutes
        hat.material.metalness = 0.1; // Setzt die Metallizität
        avatar.add(hat);

        // Gliedmaßen 
        const leftArmGroup = new THREE.Group();
        leftArmGroup.position.set(0.7, chest.position.y + 0.45, 0);
        avatar.add(leftArmGroup);
        const upperArmGeom = new THREE.CylinderGeometry(0.15, 0.12, 0.8, 16);
        const foreArmGeom = new THREE.CylinderGeometry(0.12, 0.08, 0.7, 16);
        const handGeom = new THREE.SphereGeometry(0.1, 16, 8);
        const leftUpperArm = new THREE.Mesh(upperArmGeom, bodyMaterial);
        leftUpperArm.position.y = -0.4;
        const leftForeArm = new THREE.Mesh(foreArmGeom, bodyMaterial);
        leftForeArm.position.y = leftUpperArm.position.y - 0.7;
        const leftHand = new THREE.Mesh(handGeom, handFootMaterial);
        leftHand.position.y = leftForeArm.position.y - 0.4;
        leftArmGroup.add(leftUpperArm, leftForeArm, leftHand);
        const rightArmGroup = new THREE.Group();
        rightArmGroup.position.set(-0.7, chest.position.y + 0.45, 0);
        avatar.add(rightArmGroup);
        const rightUpperArm = new THREE.Mesh(upperArmGeom, bodyMaterial);
        rightUpperArm.position.y = -0.4;
        const rightForeArm = new THREE.Mesh(foreArmGeom, bodyMaterial);
        rightForeArm.position.y = rightUpperArm.position.y - 0.7;
        const rightHand = new THREE.Mesh(handGeom, handFootMaterial);
        rightHand.position.y = rightForeArm.position.y - 0.4;
        rightArmGroup.add(rightUpperArm, rightForeArm, rightHand);
        const leftLegGroup = new THREE.Group();
        leftLegGroup.position.set(0.25, 0.1, 0);
        avatar.add(leftLegGroup);
        const upperLegGeom = new THREE.CylinderGeometry(0.2, 0.15, 1.0, 16);
        const lowerLegGeom = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 16);
        const footGeom = new THREE.CylinderGeometry(0.1, 0.15, 0.3, 16);
        const leftUpperLeg = new THREE.Mesh(upperLegGeom, bodyMaterial);
        leftUpperLeg.position.y = -0.5;
        const leftLowerLeg = new THREE.Mesh(lowerLegGeom, bodyMaterial);
        leftLowerLeg.position.y = leftUpperLeg.position.y - 1.0;
        const leftFoot = new THREE.Mesh(footGeom, handFootMaterial);
        leftFoot.position.y = leftLowerLeg.position.y - 0.6;
        leftFoot.rotation.x = -Math.PI / 2;
        leftLegGroup.add(leftUpperLeg, leftLowerLeg, leftFoot);
        const rightLegGroup = new THREE.Group();
        rightLegGroup.position.set(-0.25, 0.1, 0);
        avatar.add(rightLegGroup);
        const rightUpperLeg = new THREE.Mesh(upperLegGeom, bodyMaterial);
        rightUpperLeg.position.y = -0.5;
        const rightLowerLeg = new THREE.Mesh(lowerLegGeom, bodyMaterial);
        rightLowerLeg.position.y = rightUpperLeg.position.y - 1.0;
        const rightFoot = new THREE.Mesh(footGeom, handFootMaterial);
        rightFoot.position.y = rightLowerLeg.position.y - 0.6;
        rightFoot.rotation.x = -Math.PI / 2;
        rightLegGroup.add(rightUpperLeg, rightLowerLeg, rightFoot);

        // Steuerung und Animation (unverändert)
        const clock = new THREE.Clock();
        let isAnimating = false;
        window.addEventListener('keydown', (event) => { if (event.key === 'w' || event.key === 's') { isAnimating = true; } });
        window.addEventListener('keyup', (event) => { if (event.key === 'w' || event.key === 's') { isAnimating = false; } });
        function animate() {
            requestAnimationFrame(animate);
            if (isAnimating) {
                const elapsedTime = clock.getElapsedTime();
                const runSpeed = 10;
                const swingAngle = Math.PI / 4;
                leftArmGroup.rotation.x = Math.sin(elapsedTime * runSpeed) * swingAngle;
                rightArmGroup.rotation.x = -Math.sin(elapsedTime * runSpeed) * swingAngle;
                leftLegGroup.rotation.x = -Math.sin(elapsedTime * runSpeed) * swingAngle;
                rightLegGroup.rotation.x = Math.sin(elapsedTime * runSpeed) * swingAngle;
            } else {
                leftArmGroup.rotation.x *= 0.9;
                rightArmGroup.rotation.x *= 0.9;
                leftLegGroup.rotation.x *= 0.9;
                rightLegGroup.rotation.x *= 0.9;
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>