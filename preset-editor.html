<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAML Preset Editor - Split View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #4fc3f7;
            font-size: 18px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn.success {
            background: #16825d;
        }

        .btn.success:hover {
            background: #1e9870;
        }

        .preset-selector {
            background: #3c3c3c;
            border: 1px solid #5a5a5a;
            color: #d4d4d4;
            padding: 6px 12px;
            border-radius: 4px;
        }

        .container {
            display: flex;
            height: calc(100vh - 60px);
        }

        .left-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
        }

        .right-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: #252526;
            padding: 10px 15px;
            border-bottom: 1px solid #3e3e42;
            font-weight: bold;
            color: #cccccc;
        }

        .yaml-editor {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            border: none;
            outline: none;
            padding: 15px;
            resize: none;
            line-height: 1.5;
        }

        .canvas-container {
            flex: 1;
            background: #000;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4fc3f7;
            text-align: center;
        }

        .error {
            background: #f44336;
            color: white;
            padding: 10px 15px;
            margin: 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .info {
            background: #2196f3;
            color: white;
            padding: 8px 15px;
            margin: 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status-bar {
            background: #007acc;
            color: white;
            padding: 5px 15px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .subtext { font-size: 12px; margin-top: 10px; color: #4fc3f7; }

        /* YAML Syntax Highlighting */
        .yaml-editor {
            white-space: pre;
            tab-size: 2;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ YAML Preset Editor</h1>
        <div class="controls">
            <select class="preset-selector" id="presetSelect" aria-label="Preset Template ausw√§hlen">
                <option value="">W√§hle Preset Template...</option>
                <option value="simple_world">Einfache Welt</option>
                <option value="forest">Wald-Zone</option>
                <option value="library">Bibliothek</option>
                <option value="single_terrain">Nur Terrain</option>
                <option value="single_object">Nur Objekt</option>
                <option value="single_persona">Nur NPC</option>
            </select>
            <button class="btn" id="loadBtn">üì• Laden</button>
            <button class="btn success" id="renderBtn">üé¨ Rendern</button>
            <button class="btn" id="resetBtn">üîÑ Reset</button>
        </div>
    </div>

    <div class="container">
        <div class="left-panel">
            <div class="panel-header">
                üìù YAML Editor
            </div>
            <textarea class="yaml-editor" id="yamlEditor" placeholder="# Deine YAML-Welt hier eingeben...
name: 'Test World'
description: 'Eine Test-Welt f√ºr Presets'

terrain:
  preset: 'forest_floor'

objects:
  - preset: 'tree_simple'
    position: [0, 0, 0]

personas:
  - preset: 'npc_plain'
    name: 'Test NPC'
    position: [3, 0, 3]"></textarea>
        </div>

        <div class="right-panel">
            <div class="panel-header">
                üéÆ 3D Vorschau
            </div>
            <div class="canvas-container">
                <canvas id="renderCanvas"></canvas>
                <div class="loading" id="loadingIndicator">
                    <div>üåç Welt wird geladen...</div>
                    <div class="subtext">THREE.js wird initialisiert</div>
                </div>
            </div>
            <div class="status-bar">
                <span id="statusText">Bereit zum Rendern</span>
                <span id="objectCount">0 Objekte</span>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Vereinfachte YAML-Visualisierung ohne Module-Dependencies

        class PresetEditor {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentZone = null;
                this.animationId = null;

                this.initializeElements();
                this.initializePresetTemplates();
                this.setupEventListeners();
                this.initThreeJS();
            }

            initializeElements() {
                this.yamlEditor = document.getElementById('yamlEditor');
                this.canvas = document.getElementById('renderCanvas');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.statusText = document.getElementById('statusText');
                this.objectCount = document.getElementById('objectCount');
                this.presetSelect = document.getElementById('presetSelect');
                this.loadBtn = document.getElementById('loadBtn');
                this.renderBtn = document.getElementById('renderBtn');
                this.resetBtn = document.getElementById('resetBtn');
            }

            initializePresetTemplates() {
                this.templates = {
                    simple_world: `# Einfache Test-Welt
name: "Einfache Welt"
description: "Zum Testen der Presets"
id: "test-simple"

environment:
  ambient_light: 0.6
  sun_intensity: 0.8

terrain:
  preset: "grass_flat"

objects:
  - preset: "tree_simple"
    position: [3, 0, 3]
  
  - preset: "rock_small"
    position: [-3, 0, -3]

personas:
  - preset: "npc_plain"
    name: "Test NPC"
    position: [0, 0, 5]`,

                    forest: `# Wald-Zone mit Presets
name: "Preset Wald"
description: "Wald mit allen Preset-Features"
id: "test-forest"

environment:
  ambient_light: 0.4
  sun_intensity: 0.3

terrain:
  preset: "forest_floor"

objects:
  - preset: "tree_simple"
    position: [5, 0, 5]
    scale: [2, 2.5, 2]
    
  - preset: "mushroom_small"
    position: [2, 0, -3]
    interactive: true
    
  - preset: "stone_circle_thin"
    position: [0, 0, 0]

personas:
  - preset: "npc_guardian"
    name: "Waldw√§chter"
    position: [-3, 0, 8]
    
  - preset: "npc_fairy"
    name: "Waldfee"
    position: [3, 0, -5]`,

                    library: `# Bibliotheks-Zone
name: "Preset Bibliothek"
description: "Bibliothek mit Scholar NPCs"
id: "test-library"

environment:
  ambient_light: 0.8
  sun_intensity: 0.0

terrain:
  preset: "marble_flat"

objects:
  - preset: "bookshelf"
    position: [5, 0, 5]
    
  - preset: "bookshelf"
    position: [-5, 0, 5]
    
  - preset: "crystal"
    position: [0, 0, 0]

personas:
  - preset: "npc_scholar"
    name: "Bibliothekar"
    position: [0, 0, 8]`,

                    single_terrain: `# Nur Terrain Test
name: "Terrain Test"
id: "test-terrain"

environment:
  ambient_light: 0.6

terrain:
  preset: "forest_floor"
  size: [40, 40]`,

                    single_object: `# Nur Objekt Test
name: "Objekt Test"
id: "test-object"

environment:
  ambient_light: 0.6

terrain:
  preset: "grass_flat"
  size: [20, 20]

objects:
  - preset: "tree_simple"
    position: [0, 0, 0]
    scale: [2, 3, 2]`,

                    single_persona: `# Nur NPC Test
name: "NPC Test"
id: "test-npc"

environment:
  ambient_light: 0.6

terrain:
  preset: "grass_flat"
  size: [20, 20]

personas:
  - preset: "npc_plain"
    name: "Test Character"
    position: [0, 0, 3]`
                };
            }

            setupEventListeners() {
                this.loadBtn.addEventListener('click', () => this.loadTemplate());
                this.renderBtn.addEventListener('click', () => this.renderYAML());
                this.resetBtn.addEventListener('click', () => this.resetScene());
                
                // Auto-render bei YAML-√Ñnderungen (mit Debounce und besserer Fehlerbehandlung)
                let timeout;
                this.yamlEditor.addEventListener('input', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        // Nur rendern wenn YAML vollst√§ndig aussieht
                        const yamlText = this.yamlEditor.value.trim();
                        console.log('üîÑ Auto-render check:', { 
                            hasText: !!yamlText, 
                            isValid: this.isValidTypingState(yamlText),
                            textLength: yamlText.length 
                        });
                        
                        if (yamlText && this.isValidTypingState(yamlText)) {
                            console.log('‚úÖ Auto-rendering YAML...');
                            this.renderYAML();
                        } else {
                            console.log('‚è≥ Waiting for complete YAML...');
                        }
                    }, 1500); // L√§ngere Wartezeit
                });

                // Kamera-Kontrollen
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
                window.addEventListener('resize', () => this.onWindowResize());
            }

            isValidTypingState(text) {
                // Schnellchecks
                if (!text || !text.trim()) return false;
                const trimmed = text.trim();

                // 1) Offensichtliche Tipp-Zust√§nde (ohne false-positives bei g√ºltigen Bl√∂cken)
                const loosePatterns = [
                    /^\s*-\s*$/m,           // leeres Listen-Item
                    /^\s*preset:\s*$/m,     // preset: ohne Wert
                    /\[\s*\d+\s*,?\s*$/,   // unvollst√§ndiges Array [1,
                ];
                for (const p of loosePatterns) {
                    if (p.test(trimmed)) {
                        console.log('üö´ Typing pattern detected:', p.toString());
                        return false;
                    }
                }

                // 2) Kontext-basierter Check f√ºr Key-Zeilen: "key:" ist nur Tipp, wenn keine sinnvolle Folgezeile folgt
                const lines = trimmed.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const next = lines[i + 1];

                    const isKeyOnly = /^\s*[\w-]+:\s*$/.test(line);
                    if (isKeyOnly) {
                        // Wenn n√§chste Zeile fehlt oder nur Leerraum ‚Üí noch Tippzustand
                        if (!next || /^\s*$/.test(next)) {
                            console.log('üö´ Key with empty or missing next line:', line);
                            return false;
                        }
                        // Wenn n√§chste Zeile nicht einger√ºckt ist ‚Üí Struktur noch nicht begonnen
                        const isIndentedNext = /^\s+/.test(next);
                        if (!isIndentedNext) {
                            console.log('üö´ Key without indented content yet:', line);
                            return false;
                        }
                    }
                }

                // 3) Robuster Check auf ungeschlossene Strings per Quote-Z√§hlung
                const dqCount = (trimmed.match(/\"/g) || []).length; // count "
                const sqCount = (trimmed.match(/'/g) || []).length;    // count '
                // Wenn ungerade Anzahl, ist irgendein String offen
                if (dqCount % 2 !== 0 || sqCount % 2 !== 0) {
                    console.log('üö´ Unmatched quotes detected (single or double)');
                    return false;
                }

                // 4) YAML Parse-Probe
                try {
                    const parsed = jsyaml.load(trimmed);
                    const isObject = parsed !== null && typeof parsed === 'object';
                    if (!isObject) {
                        console.log('üö´ YAML parsed but not an object');
                        return false;
                    }
                } catch (e) {
                    console.log('‚ùå YAML parse error (still typing?):', e.message);
                    return false;
                }

                // 5) Sonderfall: minimales, aber g√ºltiges Snippet erlauben (z.B. nur terrain + preset)
                // Wenn wir bis hierher kommen, ist es renderbar
                return true;
            }

            loadTemplate() {
                const selectedTemplate = this.presetSelect.value;
                if (selectedTemplate && this.templates[selectedTemplate]) {
                    this.yamlEditor.value = this.templates[selectedTemplate];
                    this.renderYAML();
                }
            }

            async initThreeJS() {
                try {
                    // Scene
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x87ceeb);

                    // Camera
                    this.camera = new THREE.PerspectiveCamera(75, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 1000);
                    this.camera.position.set(15, 15, 15);
                    this.camera.lookAt(0, 0, 0);

                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                    this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    if (THREE.sRGBEncoding) {
                        this.renderer.outputEncoding = THREE.sRGBEncoding;
                    }

                    // Lights
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                    this.scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(10, 20, 10);
                    directionalLight.castShadow = true;
                    this.scene.add(directionalLight);

                    this.loadingIndicator.style.display = 'none';
                    this.updateStatus('THREE.js initialisiert - Bereit zum Visualisieren');
                    
                    this.animate();

                } catch (error) {
                    console.error('THREE.js Initialisierung fehlgeschlagen:', error);
                    this.showError('THREE.js konnte nicht geladen werden: ' + error.message);
                }
            }

            async renderYAML() {
                const yamlText = this.yamlEditor.value.trim();
                if (!yamlText) {
                    this.updateStatus('Kein YAML-Code vorhanden');
                    return;
                }

                try {
                    this.updateStatus('Visualisiere YAML...');
                    
                    // Clear previous scene
                    this.resetScene(false);

                    // Parse YAML
                    const worldData = jsyaml.load(yamlText);
                    
                    // Create simple visualization instead of full world loading
                    this.createSimpleVisualization(worldData);

                    this.updateStatus('‚úÖ YAML erfolgreich visualisiert');

                } catch (error) {
                    console.error('YAML Visualisierung Error:', error);
                    
                    // Nur echte Fehler anzeigen, nicht Tipp-Fehler
                    if (error.name === 'YAMLException' && error.message.includes('colon is missed')) {
                        this.updateStatus('‚ö†Ô∏è YAML wird getippt... (Doppelpunkt fehlt)');
                    } else {
                        this.showError('YAML Fehler: ' + error.message);
                        this.updateStatus('‚ùå YAML Visualisierung fehlgeschlagen');
                    }
                }
            }

            createSimpleVisualization(worldData) {
                const group = new THREE.Group();
                let objectCount = 0;

                // // TEST: Sichtbare Test-Box hinzuf√ºgen (kleiner und h√∂her)
                // const testGeo = new THREE.BoxGeometry(2, 0.5, 2);
                // const testMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                // const testCube = new THREE.Mesh(testGeo, testMat);
                // testCube.position.set(10, 2, 10); // Weiter weg und h√∂her
                // group.add(testCube);
                // console.log('üî¥ Test-W√ºrfel zur Zone hinzugef√ºgt (preset-editor)');
                // objectCount++;

                // Terrain visualization mit Preset-Support
                if (worldData.terrain) {
                    let terrainConfig = worldData.terrain;
                    
                    // Preset aufl√∂sen
                    if (terrainConfig.preset) {
                        const presetDefaults = {
                            'forest_floor': {
                                type: 'hills',
                                texture: 'forest_floor',
                                color: '#4a7c1e',
                                amplitude: 2.5,
                                size: [50, 50]
                            },
                            'grass_flat': {
                                type: 'flat',
                                color: '#4a7c1e',
                                size: [50, 50]
                            }
                        };
                        
                        const preset = presetDefaults[terrainConfig.preset];
                        if (preset) {
                            terrainConfig = { ...preset, ...terrainConfig };
                        }
                    }
                    
                    const terrain = this.createSimpleTerrain(terrainConfig);
                    group.add(terrain);
                    objectCount++;
                }

                // Objects visualization mit Preset-Support
                if (worldData.objects && Array.isArray(worldData.objects)) {
                    worldData.objects.forEach((obj, index) => {
                        let objConfig = obj;
                        
                        // Preset aufl√∂sen
                        if (obj.preset) {
                            const objectPresets = {
                                'tree_simple': { type: 'tree', color: '#1a4a1a', scale: [1, 1, 1] },
                                'rock_small': { type: 'rock', color: '#8b7355', scale: [0.8, 0.8, 0.8] },
                                'crystal': { type: 'crystal', color: '#00ffff', scale: [1, 1, 1] },
                                'mushroom_small': { type: 'mushroom', color: '#8b4513', scale: [0.5, 0.8, 0.5] },
                                'stone_circle_thin': { type: 'stone_circle', color: '#696969', scale: [4, 4, 4] }
                            };
                            
                            const preset = objectPresets[obj.preset];
                            if (preset) {
                                objConfig = { ...preset, ...obj };
                            }
                        }
                        
                        const mesh = this.createSimpleObject(objConfig, index);
                        if (mesh) {
                            group.add(mesh);
                            objectCount++;
                        }
                    });
                }

                // Personas visualization mit Preset-Support
                if (worldData.personas && Array.isArray(worldData.personas)) {
                    worldData.personas.forEach((persona, index) => {
                        let personaConfig = persona;
                        
                        // Preset aufl√∂sen
                        if (persona.preset) {
                            const personaPresets = {
                                'npc_plain': { role: 'NPC', appearance: { color: '#ff6b6b', height: 1.6 } },
                                'npc_guardian': { role: 'Guardian', appearance: { color: '#4169e1', height: 1.8 } }
                            };
                            
                            const preset = personaPresets[persona.preset];
                            if (preset) {
                                personaConfig = { ...preset, ...persona };
                                // Merge nested appearance object
                                if (preset.appearance && persona.appearance) {
                                    personaConfig.appearance = { ...preset.appearance, ...persona.appearance };
                                }
                            }
                        }
                        
                        const mesh = this.createSimplePersona(personaConfig, index);
                        if (mesh) {
                            group.add(mesh);
                            objectCount++;
                        }
                    });
                }

                this.scene.add(group);
                this.currentZone = { group };
                this.updateObjectCount(objectCount);
            }

            createSimpleTerrain(terrainConfig) {
                const size = terrainConfig.size || [50, 50];
                const width = size[0];
                const height = size[1];
                const isHills = terrainConfig.type === 'hills' || terrainConfig.preset === 'forest_floor';
                const seg = isHills ? 96 : 2;
                const geometry = new THREE.PlaneGeometry(width, height, seg, seg);
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color(terrainConfig.color || '#4a7c1e'),
                    side: THREE.FrontSide,
                    roughness: 0.75,
                    metalness: 0.05
                });

                if (isHills) {
                    const pos = geometry.attributes.position;
                    const v = new THREE.Vector3();
                    const amplitude = (typeof terrainConfig.amplitude === 'number') ? terrainConfig.amplitude : 2.5;

                    // Parameter identisch zu YAMLWorldLoader
                    const flatRadius = (typeof terrainConfig.flat_radius === 'number') ? terrainConfig.flat_radius : Math.min(width, height) * 0.15;
                    const blendRadius = (typeof terrainConfig.blend_radius === 'number') ? terrainConfig.blend_radius : Math.min(width, height) * 0.25;
                    const outerGain = (typeof terrainConfig.outer_gain === 'number') ? terrainConfig.outer_gain : 1.0;

                    const centerX = 0, centerY = 0;
                    const maxR = Math.hypot(width * 0.5, height * 0.5);

                    for (let i = 0; i < pos.count; i++) {
                        v.fromBufferAttribute(pos, i);
                        const x = v.x, y = v.y;

                        const wave1 = Math.sin(x * 0.08) * Math.cos(y * 0.08) * 0.9;
                        const wave2 = Math.sin(x * 0.18 + 1.2) * Math.cos(y * 0.14 + 0.7) * 0.6;
                        const wave3 = Math.sin(x * 0.3 + 2.4) * Math.cos(y * 0.22 + 1.7) * 0.3;
                        const baseElevation = (wave1 + wave2 + wave3) * amplitude;

                        const r = Math.hypot(x - centerX, y - centerY);
                        let blend;
                        if (r <= flatRadius) blend = 0; else if (r >= flatRadius + blendRadius) blend = 1; else {
                            const t = (r - flatRadius) / Math.max(1e-6, blendRadius);
                            blend = t * t * (3 - 2 * t);
                        }
                        const radialFactor = outerGain === 1.0 ? 1.0 : (1 + (outerGain - 1) * (r / maxR));

                        const elevation = baseElevation * blend * radialFactor;
                        pos.setZ(i, elevation);
                    }
                    pos.needsUpdate = true;
                    geometry.computeVertexNormals();
                }

                if (terrainConfig.texture === 'forest_floor' || terrainConfig.preset === 'forest_floor') {
                    const c = document.createElement('canvas');
                    c.width = 512; c.height = 512;
                    const ctx = c.getContext('2d');
                    const grad = ctx.createLinearGradient(0,0,512,512);
                    grad.addColorStop(0, '#2a3f20');
                    grad.addColorStop(1, '#20351a');
                    ctx.fillStyle = grad; ctx.fillRect(0,0,512,512);
                    for(let i=0;i<400;i++){
                        const x = Math.random()*512, y = Math.random()*512, r = 2+Math.random()*6;
                        ctx.fillStyle = `rgba(80,120,70,${0.08+Math.random()*0.12})`;
                        ctx.beginPath(); ctx.ellipse(x,y,r*1.2,r,Math.random()*Math.PI,0,Math.PI*2); ctx.fill();
                    }
                    const tex = new THREE.CanvasTexture(c);
                    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                    tex.repeat.set(4,4);
                    if (THREE.sRGBEncoding) tex.encoding = THREE.sRGBEncoding;
                    material.map = tex;
                    material.color = new THREE.Color('#ffffff');
                    material.needsUpdate = true;
                }

                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = (typeof terrainConfig.y === 'number') ? terrainConfig.y : 0.01;
                mesh.name = 'terrain';
                mesh.renderOrder = -10;
                material.transparent = false;
                material.depthWrite = true;
                material.depthTest = true;
                return mesh;
            }

            createSimpleObject(objConfig, index) {
                let geometry;
                let color = objConfig.color || '#8b4513';

                // Preset colors
                if (objConfig.preset === 'tree_simple') color = '#1a4a1a';
                else if (objConfig.preset === 'crystal') color = '#00ffff';
                else if (objConfig.preset === 'mushroom_small') color = '#8b4513';

                switch (objConfig.preset || objConfig.type) {
                    case 'tree_simple':
                    case 'tree':
                        geometry = new THREE.ConeGeometry(1, 3, 8);
                        break;
                    case 'rock_small':
                    case 'rock':
                        geometry = new THREE.DodecahedronGeometry(0.8);
                        break;
                    case 'mushroom_small':
                    case 'mushroom':
                        geometry = new THREE.CylinderGeometry(0.5, 0.2, 1, 12);
                        break;
                    case 'stone_circle_thin':
                    case 'stone_circle':
                        geometry = new THREE.TorusGeometry(2, 0.2, 8, 16);
                        break;
                    case 'crystal':
                        geometry = new THREE.OctahedronGeometry(1);
                        break;
                    case 'bookshelf':
                        geometry = new THREE.BoxGeometry(2, 4, 0.5);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }

                const material = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                
                if (objConfig.position) {
                    mesh.position.set(...objConfig.position);
                }
                if (objConfig.scale) {
                    mesh.scale.set(...objConfig.scale);
                }
                
                // Spezifische Ausrichtung f√ºr Stone Circle (flach auf den Boden)
                if (objConfig.preset === 'stone_circle_thin' || objConfig.type === 'stone_circle') {
                    mesh.rotation.x = Math.PI / 2; // 90 Grad um X-Achse = flach auf Boden
                    mesh.position.y = Math.max(mesh.position.y || 0, 0.02); // Leicht √ºber Boden gegen Z-Fighting
                }
                
                mesh.name = `${objConfig.preset || objConfig.type}_${index}`;
                return mesh;
            }

            createSimplePersona(personaConfig, index) {
                // Ersatz f√ºr CapsuleGeometry (nicht in allen Three Versionen vorhanden)
                const group = new THREE.Group();

                const height = (personaConfig.appearance?.height || 1.4);
                const bodyHeight = Math.max(0.8, height); // K√∂rperzylinder
                const radius = 0.5; // Breite

                const cylGeom = new THREE.CylinderGeometry(radius, radius, bodyHeight, 12);
                const sphereGeom = new THREE.SphereGeometry(radius, 12, 12);

                let color = '#ff6b6b';
                if (personaConfig.preset === 'npc_fairy') color = '#ffd700';
                else if (personaConfig.preset === 'npc_scholar') color = '#2f4f4f';
                else if (personaConfig.preset === 'npc_guardian') color = '#8fbc8f';
                else if (personaConfig.appearance?.color) color = personaConfig.appearance.color;

                const material = new THREE.MeshLambertMaterial({ color });

                const body = new THREE.Mesh(cylGeom, material);
                body.position.y = 0; // Mittelpunkt am Ursprung
                group.add(body);

                const headTop = new THREE.Mesh(sphereGeom, material);
                headTop.position.y = bodyHeight/2;
                group.add(headTop);

                const headBottom = new THREE.Mesh(sphereGeom, material);
                headBottom.position.y = -bodyHeight/2;
                group.add(headBottom);

                if (personaConfig.position) {
                    group.position.set(...personaConfig.position);
                    group.position.y += 1; // etwas √ºber Boden
                }

                group.name = personaConfig.name || `persona_${index}`;
                return group;
            }

            resetScene(updateStatus = true) {
                // Remove current zone
                if (this.currentZone) {
                    this.scene.remove(this.currentZone.group);
                    this.currentZone = null;
                }

                if (updateStatus) {
                    this.updateStatus('Szene zur√ºckgesetzt');
                    this.updateObjectCount(0);
                }
            }

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                // Simple camera rotation for preview
                if (this.currentZone) {
                    const time = Date.now() * 0.0005;
                    this.camera.position.x = Math.cos(time) * 20;
                    this.camera.position.z = Math.sin(time) * 20;
                    this.camera.lookAt(0, 0, 0);
                }

                this.renderer.render(this.scene, this.camera);
            }

            // Helper methods
            updateStatus(text) {
                this.statusText.textContent = text;
            }

            updateObjectCount(count) {
                this.objectCount.textContent = `${count} Objekte`;
            }

            showError(message) {
                // Remove existing errors
                const existingError = document.querySelector('.error');
                if (existingError) existingError.remove();

                // Show new error
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.querySelector('.right-panel').appendChild(errorDiv);

                // Auto-remove after 5 seconds
                setTimeout(() => errorDiv.remove(), 5000);
            }

            onMouseDown(event) {
                // Simple camera controls could go here
            }

            onWheel(event) {
                // Zoom control
                event.preventDefault();
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                this.camera.position.multiplyScalar(scale);
            }

            onWindowResize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            new PresetEditor();
        });
    </script>
</body>
</html>
