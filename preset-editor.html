<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAML Preset Editor - Split View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #4fc3f7;
            font-size: 18px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn.success {
            background: #16825d;
        }

        .btn.success:hover {
            background: #1e9870;
        }

        .preset-selector {
            background: #3c3c3c;
            border: 1px solid #5a5a5a;
            color: #d4d4d4;
            padding: 6px 12px;
            border-radius: 4px;
        }

        .container {
            display: flex;
            height: calc(100vh - 60px);
        }

        .left-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
        }

        .right-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: #252526;
            padding: 10px 15px;
            border-bottom: 1px solid #3e3e42;
            font-weight: bold;
            color: #cccccc;
        }

        .yaml-editor {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            border: none;
            outline: none;
            padding: 15px;
            resize: none;
            line-height: 1.5;
        }

        .canvas-container {
            flex: 1;
            background: #000;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4fc3f7;
            text-align: center;
        }

        .error {
            background: #f44336;
            color: white;
            padding: 10px 15px;
            margin: 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .info {
            background: #2196f3;
            color: white;
            padding: 8px 15px;
            margin: 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status-bar {
            background: #007acc;
            color: white;
            padding: 5px 15px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .subtext { font-size: 12px; margin-top: 10px; color: #4fc3f7; }

        /* YAML Syntax Highlighting */
        .yaml-editor {
            white-space: pre;
            tab-size: 2;
        }
    </style>
    
    <!-- Import Map wie in index.html -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
      }
    }
    </script>

    <!-- YAML Parser -->
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>üéØ YAML Preset Editor</h1>
        <div class="controls">
            <!-- Suche in gespeicherten Welten (IndexedDB/Dexie via nostrService) -->
            <input class="preset-selector" id="worldSearchInput" placeholder="üîé gespeicherte Welt suchen (ID, Name, npub‚Ä¶)" title="Suche in lokal gespeicherten Welt-Genesis (Dexie)">
            <div id="worldSearchResults" style="position:absolute; background:#252526; border:1px solid #3e3e42; max-height:250px; overflow:auto; display:none; z-index:10;"></div>

            <select class="preset-selector" id="presetSelect" aria-label="Preset Template ausw√§hlen">
                <option value="">W√§hle Preset Template...</option>
                <optgroup label="Lokale Presets (eingebaut)">
                    <option value="simple_world">Einfache Welt</option>
                    <option value="forest">Wald-Zone</option>
                    <option value="library">Bibliothek</option>
                    <option value="collision_test">Kollisions-Test</option>
                    <option value="skybox_test">Skybox Test</option>
                    <option value="player_test">YAML Player Test</option>
                    <option value="single_terrain">Nur Terrain</option>
                    <option value="single_object">Nur Objekt</option>
                    <option value="single_persona">Nur NPC</option>
                </optgroup>
                <optgroup label="Worlds aus /worlds (*.yaml)" id="worldFilesGroup">
                    <option value="" disabled>(wird geladen ‚Ä¶)</option>
                </optgroup>
            </select>

            <!-- NostrWorld Controls (Router v1: worldId) -->
            <input class="preset-selector" id="worldIdInput" placeholder="worldId (z.B. demo-world)" title="Welt-ID (NIP-33 d=worldId)">
            <button class="btn" id="newWorldBtn" title="Neue leere Welt mit eindeutiger WORLD_ID">‚ûï Neu</button>
            <button class="btn" id="loadWorldBtn" title="Genesis 30311 aus Factory laden" disabled style="opacity:0.5; pointer-events:none;">üåê Laden</button>
            <button class="btn success" id="saveGenesisBtn" title="Als Genesis 30311 speichern (replaceable via NIP-33)">üíæ Speichern (Genesis)</button>
            <button class="btn" id="savePatchBtn" title="Als Patch 30312 speichern (create/update/delete)">üß© Speichern (Patch)</button>

            <button class="btn success" id="renderBtn">üé¨ Rendern</button>
            <button class="btn" id="resetBtn">üîÑ Reset</button>
        </div>
    </div>

    <div class="container">
        <div class="left-panel">
            <div class="panel-header">
                üìù YAML Editor
            </div>
            <textarea class="yaml-editor" id="yamlEditor" placeholder="# Deine YAML-Welt hier eingeben...
name: 'Test World'
description: 'Eine Test-Welt f√ºr Presets'

terrain:
  preset: 'forest_floor'

objects:
  - preset: 'tree_simple'
    position: [0, 0, 0]

personas:
  - preset: 'npc_plain'
    name: 'Test NPC'
    position: [3, 0, 3]"></textarea>
        </div>

        <div class="right-panel">
            <div class="panel-header">
                üéÆ 3D Vorschau
            </div>
            <div class="canvas-container">
                <canvas id="renderCanvas"></canvas>
                <div class="loading" id="loadingIndicator">
                    <div>üåç Welt wird geladen...</div>
                    <div class="subtext">THREE.js wird initialisiert</div>
                </div>
            </div>
            <div class="status-bar">
                <span id="statusText">Bereit zum Rendern</span>
                <span id="objectCount">0 Objekte</span>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script type="module">
        import * as THREE from 'three';
        import { buildZoneFromSpec } from './js/world-generation/index.js';
        import { resolveWorldSpec } from './js/world-generation/resolve.js';
        import { getNostrService } from './js/core/net/nostr-service-factory.js';
        import { APP_MODE } from './js/core/net/config.js';
        import { generateUniqueId } from './js/core/net/unique-id.js';
        
        async function fetchText(path) {
          const res = await fetch(path);
          if (!res.ok) throw new Error('Konnte Datei nicht laden: ' + path);
          return await res.text();
        }
        async function listWorldFiles() {
          return [
            'worlds/night-test.yaml',
            'worlds/skybox-test.yaml',
            'worlds/storm-test.yaml',
            'worlds/sunset-test.yaml',
            'worlds/zone_village_center.yaml',
            'worlds/zone-archive.yaml',
            'worlds/zone-buildings-demo.yaml',
            'worlds/zone-collections-demo.yaml',
            'worlds/zone-collision-test.yaml',
            'worlds/zone-deterministic-test.yaml',
            'worlds/zone-forest.yaml',
            'worlds/zone-gates-demo.yaml',
            'worlds/zone-path-demo.yaml',
            'worlds/zone-path-test.yaml',
            'worlds/zone-player-test.yaml',
            'worlds/zone-preset-test.yaml',
            'worlds/zone-rock-test.yaml',
            'worlds/zone-seed-demo.yaml',
            'worlds/zone-seed-variant.yaml',
            'worlds/zone-simple-seed-test.yaml',
            'worlds/zone-start.yaml',
            'worlds/zone-terrain-height-test.yaml',
            'worlds/zone-village-demo.yaml',
            'worlds/zone-welcome.yaml'
          ];
        }
        function deriveCopyId(baseId) {
          const short = crypto.randomUUID().split('-')[0];
          const sanitized = String(baseId || 'world').toLowerCase().replace(/[^a-z0-9-_]/g,'-');
          return `${sanitized}-${short}`;
        }
        function safeYamlParse(str) {
          try { return window.jsyaml.load(str); } catch (e) { throw new Error('YAML-Fehler: ' + e.message); }
        }
        function safeYamlDump(obj) {
          try { return window.jsyaml.dump(obj, { lineWidth: 120 }); } catch (e) { throw new Error('YAML-Serialize-Fehler: ' + e.message); }
        }
        // Entfernt ausschlie√ülich root.id (Single Source of Truth: ID ist systemseitig)
        function stripRootId(obj) {
          if (obj && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'id')) {
            try { delete obj.id; } catch {}
          }
          return obj;
        }
        // Option: id in Export aufnehmen (Default: false)
        let exportIncludeId = false; // kann √ºber UI/Config umgeschaltet werden
        function uid(prefix='id') { return `${prefix}-${crypto.randomUUID().split('-')[0]}`; }
        function nowSec() { return Math.floor(Date.now()/1000); }
        function makeATag(author, worldId) { return `30311:${author}:${worldId}`; }

        class PresetEditor {
            constructor() {
                this.scene = null; this.camera=null; this.renderer=null; this.currentZone=null; this.animationId=null;
                this.currentWorldId = '';
                this.currentGenesisAuthor = null; // filled from identity
                this.currentGenesisEvent = null;  // last loaded/saved genesis
                this.nostr = null;

                this.initializeElements(); this.initializePresetTemplates(); this.setupEventListeners(); this.initThreeJS();
                // Starte Nostr-Initialisierung asynchron (Methode ist unten definiert)
                this.initNostr();
                // UI: worldIdInput schreibgesch√ºtzt
                if (this.worldIdInput) { this.worldIdInput.readOnly = true; this.worldIdInput.setAttribute('aria-readonly', 'true'); }
            }

            initializeElements() {
                this.yamlEditor = document.getElementById('yamlEditor');
                this.canvas = document.getElementById('renderCanvas');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.statusText = document.getElementById('statusText');
                this.objectCount = document.getElementById('objectCount');
                this.presetSelect = document.getElementById('presetSelect');
                this.loadBtn = document.getElementById('loadBtn');
                this.renderBtn = document.getElementById('renderBtn');
                this.resetBtn = document.getElementById('resetBtn');

                // Gruppe f√ºr /worlds
                this.worldFilesGroup = document.getElementById('worldFilesGroup');
                this.worldFilesGroup = document.getElementById('worldFilesGroup');

                // Nostr UI
                this.worldIdInput = document.getElementById('worldIdInput');
                this.newWorldBtn = document.getElementById('newWorldBtn');
                this.loadWorldBtn = document.getElementById('loadWorldBtn');
                this.saveGenesisBtn = document.getElementById('saveGenesisBtn');
                this.savePatchBtn = document.getElementById('savePatchBtn');

                // Sucheingabe
                this.worldSearchInput = document.getElementById('worldSearchInput');
                this.worldSearchResults = document.getElementById('worldSearchResults');
            }

            async initializePresetTemplates() {
                this.templates = {
                    simple_world: `# Einfache Test-Welt
name: "Einfache Welt"
description: "Zum Testen der Presets"
id: "test-simple"

environment:
  skybox: "sunset"
  ambient_light: 0.6
  sun_intensity: 0.8

terrain:
  preset: "grass_flat"

objects:
  - preset: "tree_simple"
    position: [3, 0, 3]
  
  - preset: "rock_small"
    position: [-3, 0, -3]

personas:
  - preset: "npc_plain"
    name: "Test NPC"
    position: [0, 0, 5]`,

                    forest: `# Wald-Zone mit Presets
name: "Preset Wald"
description: "Wald mit allen Preset-Features"
id: "test-forest"

environment:
  skybox: "night"
  ambient_light: 0.4
  sun_intensity: 0.3

terrain:
  preset: "forest_floor"

objects:
  - preset: "tree_simple"
    position: [5, 0, 5]
    scale: [2, 2.5, 2]
    
  - preset: "mushroom_small"
    position: [2, 0, -3]
    interactive: true
    
  - preset: "stone_circle_thin"
    position: [0, 0, 0]

personas:
  - preset: "npc_guardian"
    name: "Waldw√§chter"
    position: [-3, 0, 8]
    
  - preset: "npc_fairy"
    name: "Waldfee"
    position: [3, 0, -5]`,

                    library: `# Bibliotheks-Zone
name: "Preset Bibliothek"
description: "Bibliothek mit Scholar NPCs"
id: "test-library"

environment:
  ambient_light: 0.8
  sun_intensity: 0.0

terrain:
  preset: "marble_flat"

objects:
  - preset: "bookshelf"
    position: [5, 0, 5]
    
  - preset: "bookshelf"
    position: [-5, 0, 5]
    
  - preset: "crystal"
    position: [0, 0, 0]

personas:
  - preset: "npc_scholar"
    name: "Bibliothekar"
    position: [0, 0, 8]`,

                    collision_test: `# Kollisions-Test Zone
name: "Kollisions-Test"
description: "Testet Collections mit Kollisionserkennung"
id: "collision-test"

environment:
  ambient_light: 0.6
  sun_intensity: 0.8

terrain:
  preset: "grass_flat"
  size: [40, 40]

# NPCs werden zuerst platziert
personas:
  - preset: "npc_guardian"
    name: "Dorfw√§chter"
    position: [0, 0, 0]
    
  - preset: "npc_plain"
    name: "Dorfbewohner"
    position: [8, 0, 8]

# Collections mit Kollisionserkennung
objects:
  # Village Collection mit Kollisionserkennung
  - collections: ["village"]
    count: 12
    enable_collision_detection: true
    npc_buffer_distance: 4
    object_buffer_distance: 2
    
  # Forest Objects
  - collections: ["forest_objects"]
    count: 8
    enable_collision_detection: true
    npc_buffer_distance: 2
    object_buffer_distance: 1`,

                    skybox_test: `# Skybox Test Zone
name: "Skybox Demo"
description: "Testet verschiedene Skybox-Presets"
id: "skybox-test"

environment:
  skybox: "sunset"
  time_of_day: 0.8
  ambient_light: 0.4
  sun_intensity: 0.6

terrain:
  type: "flat"
  size: [20, 20]
  color: "#4a4a3a"

objects:
  - type: "crystal"
    position: [0, 0, 0]
    scale: [1, 1.5, 1]
    color: "#ffaa00"
    
  - type: "tree"
    position: [5, 0, 2]
    scale: [1, 2, 1]
    color: "#1a3a1a"

# Andere Skybox-Presets zum Testen:
# sunset, night, storm, mystery_dark, 
# skyline, ocean, bay, clear_day`,

                    player_test: `# YAML Player Test Zone
name: "Player Avatar Test"
description: "Testet den konfigurierbaren YAML Player"
id: "player-test"

environment:
  ambient_light: 0.7
  sun_intensity: 0.9

terrain:
  preset: "grass_flat"
  size: [30, 30]

# YAML Player Konfiguration
player:
  appearance:
    body_color: "#ff6b6b"
    skin_color: "#f4c2a1"
    hair_color: "#8b4513"
    height: 1.2
    proportions:
      head_size: 0.45
  
  style:
    hair_type: "spikes"
    accessories: ["cape"]
  
  animations:
    walking:
      arm_swing: 1.0
      leg_swing: 0.9
      speed: 12

# NPCs zum Vergleich
personas:
  - preset: "npc_plain"
    name: "Standard NPC"
    position: [5, 0, 5]

# Orientierungsobjekte
objects:
  - preset: "tree_simple"
    position: [0, 0, 8]
  - preset: "crystal"
    position: [8, 0, 0]`,

                    single_terrain: `# Nur Terrain Test
name: "Terrain Test"
id: "test-terrain"

environment:
  ambient_light: 0.6

terrain:
  preset: "forest_floor"
  size: [40, 40]`,

                    single_object: `# Nur Objekt Test
name: "Objekt Test"
id: "test-object"

environment:
  ambient_light: 0.6

terrain:
  preset: "grass_flat"
  size: [20, 20]

objects:
  - preset: "tree_simple"
    position: [0, 0, 0]
    scale: [2, 3, 2]`,

                    single_persona: `# Nur NPC Test
name: "NPC Test"
id: "test-npc"

environment:
  ambient_light: 0.6

terrain:
  preset: "grass_flat"
  size: [20, 20]

personas:
  - preset: "npc_plain"
    name: "Test Character"
    position: [0, 0, 3]`
                };
                await this.populateWorldFiles();
            }

            setupEventListeners() {
                // Guard: manche Controls existieren ggf. noch nicht in √§lteren Builds
                if (this.loadBtn) this.loadBtn.addEventListener('click', () => this.loadTemplate());
                if (this.renderBtn) this.renderBtn.addEventListener('click', () => this.renderYAML());
                if (this.resetBtn) this.resetBtn.addEventListener('click', () => this.resetScene());

                // Nostr-Controls (optional vorhanden)
                if (this.newWorldBtn) this.newWorldBtn.addEventListener('click', () => {
                    // Nur neue ID generieren, Editor-Inhalt unver√§ndert lassen
                    const newId = generateUniqueId();
                    if (this.worldIdInput) this.worldIdInput.value = newId;
                    this.updateStatus?.('Neue ID generiert: ' + newId);
                });
                // loadWorldBtn ist deaktiviert; kein Listener n√∂tig
                if (this.saveGenesisBtn) this.saveGenesisBtn.addEventListener('click', () => this.onSaveGenesis());
                if (this.savePatchBtn) this.savePatchBtn.addEventListener('click', () => this.onSavePatch());

                // Dropdown: worlds/*.yaml ‚Üí YAML sofort im Editor anzeigen, ID NEU generieren und in YAML & worldIdInput schreiben, dann rendern
                if (this.presetSelect) {
                    this.presetSelect.addEventListener('change', async () => {
                        const v = this.presetSelect.value;
                        // Eingebaute Templates
                        if (v && this.templates && this.templates[v]) {
                            try {
                                const raw = this.templates[v];
                                let spec = window.jsyaml.load(raw);
                                // Single Source of Truth: root.id entfernen
                                spec = stripRootId(spec);
                                // Neue systemseitige ID nur im System (UI) setzen
                                const uniqueId = generateUniqueId();
                                if (this.worldIdInput) this.worldIdInput.value = uniqueId;
                                // In den Editor schreiben wir YAML OHNE id
                                this.yamlEditor.value = window.jsyaml.dump(spec, { lineWidth: 120 });
                                await this.renderYAML();
                                this.updateStatus?.('Auswahl geladen.');
                            } catch (e) {
                                this.showError('Preset konnte nicht geladen werden: ' + (e?.message || e));
                            }
                            return;
                        }
                        // worlds/*.yaml Dateien
                        if (v && v.startsWith('file:')) {
                            const path = v.substring(5);
                            try {
                                const res = await fetch(path, { cache: 'no-cache' });
                                if (!res.ok) throw new Error('Konnte Datei nicht laden: ' + path);
                                const raw = await res.text();
                                let spec = window.jsyaml.load(raw);
                                // zone_id bereinigen wie bisher
                                if (spec && Object.prototype.hasOwnProperty.call(spec, 'zone_id')) {
                                    try { delete spec.zone_id; } catch {}
                                }
                                // Single Source of Truth: root.id entfernen
                                spec = stripRootId(spec);
                                // Neue systemseitige ID nur im System (UI) setzen
                                const uniqueId = generateUniqueId();
                                if (this.worldIdInput) this.worldIdInput.value = uniqueId;
                                // In den Editor schreiben wir YAML OHNE id
                                this.yamlEditor.value = window.jsyaml.dump(spec, { lineWidth: 120 });
                                await this.renderYAML();
                                this.updateStatus?.('Auswahl geladen.');
                            } catch (e) {
                                this.showError('Preset konnte nicht geladen werden: ' + (e?.message || e));
                            }
                        }
                    });
                }

                // Suche: nutzt Nostr-Service-Factory searchWorlds()
                this.worldSearchInput = document.getElementById('worldSearchInput');
                this.worldSearchResults = document.getElementById('worldSearchResults');
                const debounce = (fn, ms) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };
                const hideResults = () => { if (this.worldSearchResults) { this.worldSearchResults.style.display = 'none'; this.worldSearchResults.innerHTML = ''; this.worldSearchResults.removeAttribute('aria-activedescendant'); } };
                let searchToken = 0;

                if (this.worldSearchInput) {
                    // ARIA f√ºr Listbox
                    if (this.worldSearchResults) {
                        this.worldSearchResults.setAttribute('role', 'listbox');
                    }
                    this.worldSearchInput.addEventListener('input', debounce(async () => {
                        const q = this.worldSearchInput.value.trim();
                        const myToken = ++searchToken;
                        if (!q) { hideResults(); return; }
                        try {
                            const nostr = this.nostr || await getNostrService();
                            const items = await nostr.searchWorlds(q);
                            if (myToken !== searchToken) return; // veraltete Antwort ignorieren
                            const box = this.worldSearchResults;
                            if (!box) return;
                            box.innerHTML = '';
                            if (!items || !items.length) { hideResults(); return; }
                            box.style.display = 'block';
                            box.style.minWidth = (this.worldSearchInput.offsetWidth + 'px');

                            items.slice(0, 30).forEach((it, idx) => {
                                const div = document.createElement('div');
                                div.setAttribute('role', 'option');
                                div.id = `wsr-${idx}`;
                                div.style.padding = '6px 10px';
                                div.style.cursor = 'pointer';
                                const badge = it.type === 'patch' ? 'üß© Patch' : 'üå± Genesis';
                                div.textContent = `${it.id || '(ohne id)'} ‚Äî ${it.name || '(ohne Name)'}  [${badge}]`;
                                div.addEventListener('click', async () => {
                                    try {
                                        // Falls yaml nicht geliefert, nachladen
                                        let data = it;
                                        if (!it.yaml) {
                                            data = await nostr.getById(it.id);
                                        }
                                        if (!data || !data.yaml) throw new Error('Kein YAML gefunden');
                                        // YAML parsen und root.id entfernen, dann Editor setzen
                                        let spec = window.jsyaml.load(data.yaml);
                                        spec = stripRootId(spec);
                                        this.yamlEditor.value = window.jsyaml.dump(spec, { lineWidth: 120 });
                                        // worldIdInput auf die externe ID setzen
                                        if (this.worldIdInput && data.id) this.worldIdInput.value = data.id;
                                        await this.renderYAML();
                                        hideResults();
                                        this.updateStatus?.('Auswahl geladen.');
                                    } catch (e) {
                                        this.showError('Konnte Ergebnis nicht laden: ' + (e?.message || e));
                                    }
                                });
                                div.addEventListener('mouseover', () => div.style.background = '#2d2d30');
                                div.addEventListener('mouseout', () => div.style.background = 'transparent');
                                box.appendChild(div);
                            });

                            // Tastatursteuerung
                            let activeIndex = -1;
                            const setActive = (i) => {
                                const children = Array.from(this.worldSearchResults.children);
                                children.forEach((c, idx) => c.style.background = idx === i ? '#094771' : 'transparent');
                                if (i >= 0) this.worldSearchResults.setAttribute('aria-activedescendant', `wsr-${i}`);
                            };
                            this.worldSearchInput.onkeydown = (ev) => {
                                const children = Array.from(this.worldSearchResults.children);
                                if (ev.key === 'ArrowDown') { ev.preventDefault(); activeIndex = Math.min(children.length - 1, activeIndex + 1); setActive(activeIndex); }
                                else if (ev.key === 'ArrowUp') { ev.preventDefault(); activeIndex = Math.max(0, activeIndex - 1); setActive(activeIndex); }
                                else if (ev.key === 'Enter') {
                                    if (activeIndex >= 0 && children[activeIndex]) { children[activeIndex].click(); }
                                } else if (ev.key === 'Escape') {
                                    hideResults();
                                }
                            };
                        } catch (e) {
                            hideResults();
                        }
                    }, 300));

                    // Verstecken bei Blur
                    this.worldSearchInput.addEventListener('blur', () => setTimeout(hideResults, 200));
                }

                // Auto-render bei YAML-√Ñnderungen (debounced)
                let timeout;
                if (this.yamlEditor) this.yamlEditor.addEventListener('input', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        const yamlText = this.yamlEditor.value.trim();
                        if (yamlText && this.isValidTypingState(yamlText)) {
                            this.renderYAML();
                        }
                    }, 600);
                });

                // Kamera-Kontrollen
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
                window.addEventListener('resize', () => this.onWindowResize());
            }

            async populateWorldFiles() {
                if (!this.worldFilesGroup) return;
                this.worldFilesGroup.innerHTML = '';
                try {
                    const files = await listWorldFiles();
                    if (!files.length) {
                        const opt = document.createElement('option');
                        opt.disabled = true; opt.textContent = '(keine YAMLs gefunden)';
                        this.worldFilesGroup.appendChild(opt);
                        return;
                    }
                    for (const path of files) {
                        const opt = document.createElement('option');
                        opt.value = `file:${path}`;
                        opt.textContent = path.replace('worlds/','');
                        this.worldFilesGroup.appendChild(opt);
                    }
                } catch (e) {
                    const opt = document.createElement('option');
                    opt.disabled = true; opt.textContent = '(Fehler beim Laden der Liste)';
                    this.worldFilesGroup.appendChild(opt);
                }
            }

            // Nostr: Neue leere Welt erzeugen
            onNewWorld() {
                // beibehalten f√ºr Legacy: erzeugt neue leere YAML und setzt ID synchron
                const id = generateUniqueId();
                this.currentWorldId = id;
                if (this.worldIdInput) this.worldIdInput.value = id;

                const spec = {
                    id,
                    name: 'Neue Welt',
                    description: 'Leere Welt',
                    environment: { ambient_light: 0.6 },
                    terrain: { preset: 'grass_flat', size: [20, 20] },
                    objects: [],
                    personas: []
                };
                this.yamlEditor.value = safeYamlDump(spec);
                this.updateStatus?.('Neue Welt vorbereitet: ' + id);
            }

            // Nostr: Genesis laden
            async onLoadWorld() {
                try {
                    if (!this.nostr) { this.updateStatus?.('Nostr nicht bereit.'); return; }
                    const id = (this.worldIdInput?.value || '').trim();
                    if (!id) { this.updateStatus?.('Bitte worldId angeben.'); return; }
                    this.currentWorldId = id;

                    const author = this.currentGenesisAuthor;
                    if (!author) { this.updateStatus?.('Keine Identit√§t verf√ºgbar.'); return; }
                    const aTag = makeATag(author, id);
                    const filter = { kinds: [30311], '#a': [aTag] };
                    const events = await this.nostr.get(filter);
                    if (!events.length) { this.updateStatus?.('Keine Genesis f√ºr worldId gefunden: ' + id); return; }
                    const genesis = events.sort((a, b) => (b.created_at) - (a.created_at))[0];
                    this.currentGenesisEvent = genesis;

                    const spec = safeYamlParse(genesis.content);
                    if (!spec.id) spec.id = id;
                    this.yamlEditor.value = safeYamlDump(spec);
                    this.updateStatus?.('Genesis geladen: ' + id + ' (' + genesis.id.substring(0, 8) + '‚Ä¶ )');
                } catch (e) {
                    this.updateStatus?.('Laden fehlgeschlagen: ' + (e?.message || e));
                }
            }

            // Nostr: Als Genesis speichern (replaceable)
            async onSaveGenesis() {
                try {
                    if (!this.nostr) { this.updateStatus?.('Nostr nicht bereit.'); return; }
                    // ID aus Feld
                    let worldId = (this.worldIdInput?.value || '').trim();
                    if (!worldId) { worldId = generateUniqueId(); if (this.worldIdInput) this.worldIdInput.value = worldId; }
                    // YAML validieren
                    let spec;
                    try { spec = safeYamlParse(this.yamlEditor.value); } catch (e) { this.showError('YAML-Fehler: ' + (e?.message || e)); return; }
                    // Single Source of Truth: root.id entfernen und ohne id speichern
                    spec = stripRootId(spec);
                    // Export-Option: id nur bei expliziter Option tempor√§r hinzuf√ºgen
                    const yaml = (() => {
                      if (exportIncludeId) {
                        const tmp = { ...spec, id: worldId };
                        return safeYamlDump(tmp);
                      }
                      return safeYamlDump(spec);
                    })();

                    const ident = await this.nostr.getIdentity();
                    const author = ident.pubkey;

                    // Versuche zu speichern/√ºberschreiben
                    try {
                        await this.nostr.saveOrUpdate({ id: worldId, name: spec.name || '', type: 'genesis', yaml, pubkey: author });
                        this.updateStatus?.('Speichern erfolgreich.');
                    } catch (err) {
                        if (err && err.code === 'AUTH') {
                            const confirmCopy = window.confirm('Keine Update-Rechte. M√∂chten Sie eine Kopie anlegen?');
                            if (!confirmCopy) { this.updateStatus?.('Speichern abgebrochen.'); return; }
                            const newId = generateUniqueId();
                            spec.id = newId;
                            if (this.worldIdInput) this.worldIdInput.value = newId;
                            const yaml2 = safeYamlDump(spec);
                            await this.nostr.saveOrUpdate({ id: newId, name: spec.name || '', type: 'genesis', yaml: yaml2, pubkey: author });
                            this.updateStatus?.('Speichern erfolgreich.');
                        } else {
                            this.showError('Fehler beim Speichern.');
                        }
                    }
                } catch (e) {
                    this.showError('Fehler beim Speichern.');
                }
            }

            // Nostr: Patch speichern (MVP: kompletter YAML-Update-Vorschlag)
            async onSavePatch() {
                try {
                    if (!this.nostr) { this.updateStatus?.('Nostr nicht bereit.'); return; }
                    const id = (this.worldIdInput?.value || '').trim();
                    if (!id) { this.updateStatus?.('Bitte worldId angeben.'); return; }
                    const ident = await this.nostr.getIdentity();
                    const author = this.currentGenesisAuthor || ident.pubkey;

                    const patch = {
                        action: 'update',
                        target: 'world',
                        id,
                        payload: this.yamlEditor.value
                    };

                    const tags = [['a', makeATag(author, id)]];
                    if (this.currentGenesisEvent) {
                        tags.push(['e', this.currentGenesisEvent.id]);
                    }

                    const draft = {
                        kind: 30312,
                        created_at: Math.floor(Date.now() / 1000),
                        tags,
                        content: JSON.stringify(patch),
                        pubkey: author
                    };
                    const evt = await this.nostr.ensureSigned(draft);
                    await this.nostr.publish(evt);
                    this.updateStatus?.('Patch gespeichert (' + evt.id.substring(0, 8) + '‚Ä¶ )');
                } catch (e) {
                    this.updateStatus?.('Patch-Speichern fehlgeschlagen: ' + (e?.message || e));
                }
            }

            async initNostr() {
                try {
                    this.nostr = await getNostrService();
                    const ident = await this.nostr.getIdentity();
                    this.currentGenesisAuthor = ident.pubkey;
                    this.updateStatus?.('Nostr bereit (' + (APP_MODE) + '), pubkey: ' + ident.pubkey.substring(0,8) + '‚Ä¶');
                } catch (e) {
                    this.updateStatus?.('Nostr-Initialisierung fehlgeschlagen: ' + (e?.message || e));
                }
            }

            setupEventListeners() {
                // Guard: manche Controls existieren ggf. noch nicht in √§lteren Builds
                if (this.loadBtn) this.loadBtn.addEventListener('click', () => this.loadTemplate());
                if (this.renderBtn) this.renderBtn.addEventListener('click', () => this.renderYAML());
                if (this.resetBtn) this.resetBtn.addEventListener('click', () => this.resetScene());

                // Nostr-Controls (optional vorhanden)
                if (this.newWorldBtn) this.newWorldBtn.addEventListener('click', () => this.onNewWorld());
                if (this.loadWorldBtn) this.loadWorldBtn.addEventListener('click', () => this.onLoadWorld());
                if (this.saveGenesisBtn) this.saveGenesisBtn.addEventListener('click', () => this.onSaveGenesis());
                if (this.savePatchBtn) this.savePatchBtn.addEventListener('click', () => this.onSavePatch());

                // Dropdown: worlds/*.yaml ‚Üí YAML sofort in Editor laden, ID neu setzen, rendern
                if (this.presetSelect) {
                    this.presetSelect.addEventListener('change', async () => {
                        const v = this.presetSelect.value;
                        if (v && v.startsWith('file:')) {
                            const path = v.substring(5);
                            try {
                                const res = await fetch(path, { cache: 'no-cache' });
                                if (!res.ok) throw new Error('Konnte Datei nicht laden: ' + path);
                                const raw = await res.text();
                                this.yamlEditor.value = raw;

                                let spec;
                                try { spec = window.jsyaml.load(raw); }
                                catch (e) { this.showError('YAML-Fehler: ' + (e?.message || e)); return; }

                                if (spec && Object.prototype.hasOwnProperty.call(spec, 'zone_id')) {
                                    try { delete spec.zone_id; } catch {}
                                }

                                const desired = spec?.id || 'world';
                                const nostr = this.nostr || await getNostrService();
                                const uniqueId = await nostr.ensureUniqueWorldId(desired);
                                if (spec) {
                                    spec.id = uniqueId;
                                    if (spec.name) spec.name = `${spec.name} (Kopie)`;
                                }
                                this.yamlEditor.value = window.jsyaml.dump(spec, { lineWidth: 120 });
                                if (this.worldIdInput) this.worldIdInput.value = uniqueId;

                                await this.renderYAML();
                                this.updateStatus?.(`Preset ${path} geladen, zone_id entfernt, neue ID: ${uniqueId}`);
                            } catch (e) {
                                this.showError('Preset konnte nicht geladen werden: ' + (e?.message || e));
                            }
                        }
                    });
                }

                // Suche: gespeicherte Welten in Dexie (Genesis 30311) mit Autocomplete
                const debounce = (fn, ms) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };
                const hideResults = () => { if (this.worldSearchResults) { this.worldSearchResults.style.display = 'none'; this.worldSearchResults.innerHTML = ''; } };

                if (this.worldSearchInput) {
                    this.worldSearchInput.addEventListener('input', debounce(async () => {
                        const q = this.worldSearchInput.value.trim().toLowerCase();
                        if (!q) { hideResults(); return; }
                        try {
                            const nostr = this.nostr || await getNostrService();
                            // Hole alle lokalen Genesis (Dexie) und filtere clientseitig nach id/name/content
                            const events = await nostr.get({ kinds: [30311] });
                            const items = (events || [])
                                .map(e => {
                                    let name = '';
                                    try { const spec = window.jsyaml.load(e.content); name = spec?.name || ''; } catch {}
                                    const dTag = (e.tags || []).find(t => t[0] === 'd')?.[1] || '';
                                    return {
                                        id: e.id,
                                        worldId: dTag,
                                        name,
                                        created_at: e.created_at,
                                        content: e.content
                                    };
                                })
                                .filter(it => (it.worldId && it.worldId.toLowerCase().includes(q)) || (it.name && it.name.toLowerCase().includes(q)));

                            // Render Vorschl√§ge
                            const box = this.worldSearchResults;
                            if (!box) return;
                            box.innerHTML = '';
                            if (!items.length) { hideResults(); return; }

                            box.style.display = 'block';
                            box.style.minWidth = (this.worldSearchInput.offsetWidth + 'px');

                            items.slice(0, 20).forEach(it => {
                                const div = document.createElement('div');
                                div.style.padding = '6px 10px';
                                div.style.cursor = 'pointer';
                                div.textContent = `${it.worldId || '(ohne d)'} ‚Äî ${it.name || '(ohne Name)'}`;
                                div.addEventListener('click', () => {
                                    try {
                                        // YAML in Editor laden (genau wie bei worlds/*) ‚Äî aber root.id entfernen
                                        let spec = window.jsyaml.load(it.content);
                                        spec = stripRootId(spec);
                                        this.yamlEditor.value = window.jsyaml.dump(spec, { lineWidth: 120 });
                                        // worldIdInput setzen
                                        if (this.worldIdInput && it.worldId) this.worldIdInput.value = it.worldId;
                                        // Rendern
                                        this.renderYAML();
                                        hideResults();
                                        this.updateStatus?.(`Gespeicherte Welt geladen: ${it.worldId}`);
                                    } catch (e) {
                                        this.showError('Konnte Welt nicht laden: ' + (e?.message || e));
                                    }
                                });
                                div.addEventListener('mouseover', () => div.style.background = '#2d2d30');
                                div.addEventListener('mouseout', () => div.style.background = 'transparent');
                                box.appendChild(div);
                            });
                        } catch (e) {
                            hideResults();
                        }
                    }, 250));

                    // Verstecken bei Blur (kleines Delay, damit Clicks registriert werden)
                    this.worldSearchInput.addEventListener('blur', () => setTimeout(hideResults, 200));
                    // Positioniere die Box grob unter dem Input (einfaches CSS already)
                }

                // Auto-render bei YAML-√Ñnderungen (debounced, weniger Log)
                let timeout;
                if (this.yamlEditor) this.yamlEditor.addEventListener('input', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        const yamlText = this.yamlEditor.value.trim();
                        if (yamlText && this.isValidTypingState(yamlText)) {
                            this.renderYAML();
                        }
                    }, 600);
                });

                // Kamera-Kontrollen
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
                window.addEventListener('resize', () => this.onWindowResize());
            }

            isValidTypingState(text) {
                // Schnellchecks
                if (!text || !text.trim()) return false;
                const trimmed = text.trim();

                // 1) Offensichtliche Tipp-Zust√§nde (ohne false-positives bei g√ºltigen Bl√∂cken)
                const loosePatterns = [
                    /^\s*-\s*$/m,           // leeres Listen-Item
                    /^\s*preset:\s*$/m,     // preset: ohne Wert
                    /\[\s*\d+\s*,?\s*$/,   // unvollst√§ndiges Array [1,
                ];
                for (const p of loosePatterns) {
                    if (p.test(trimmed)) {
                        console.log('üö´ Typing pattern detected:', p.toString());
                        return false;
                    }
                }

                // 2) Kontext-basierter Check f√ºr Key-Zeilen: "key:" ist nur Tipp, wenn keine sinnvolle Folgezeile folgt
                const lines = trimmed.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const next = lines[i + 1];

                    const isKeyOnly = /^\s*[\w-]+:\s*$/.test(line);
                    if (isKeyOnly) {
                        // Wenn n√§chste Zeile fehlt oder nur Leerraum ‚Üí noch Tippzustand
                        if (!next || /^\s*$/.test(next)) {
                            console.log('üö´ Key with empty or missing next line:', line);
                            return false;
                        }
                        // Wenn n√§chste Zeile nicht einger√ºckt ist ‚Üí Struktur noch nicht begonnen
                        const isIndentedNext = /^\s+/.test(next);
                        if (!isIndentedNext) {
                            console.log('üö´ Key without indented content yet:', line);
                            return false;
                        }
                    }
                }

                // 3) Robuster Check auf ungeschlossene Strings per Quote-Z√§hlung
                const dqCount = (trimmed.match(/\"/g) || []).length; // count "
                const sqCount = (trimmed.match(/'/g) || []).length;    // count '
                // Wenn ungerade Anzahl, ist irgendein String offen
                if (dqCount % 2 !== 0 || sqCount % 2 !== 0) {
                    console.log('üö´ Unmatched quotes detected (single or double)');
                    return false;
                }

                // 4) YAML Parse-Probe
                try {
                    const parsed = jsyaml.load(trimmed);
                    const isObject = parsed !== null && typeof parsed === 'object';
                    if (!isObject) {
                        console.log('üö´ YAML parsed but not an object');
                        return false;
                    }
                } catch (e) {
                    console.log('‚ùå YAML parse error (still typing?):', e.message);
                    return false;
                }

                // 5) Sonderfall: minimales, aber g√ºltiges Snippet erlauben (z.B. nur terrain + preset)
                // Wenn wir bis hierher kommen, ist es renderbar
                return true;
            }

            loadTemplate() {
                const selectedTemplate = this.presetSelect.value;
                if (selectedTemplate && this.templates[selectedTemplate]) {
                    this.yamlEditor.value = this.templates[selectedTemplate];
                    this.renderYAML();
                }
            }

            async initThreeJS() {
                try {
                    // Scene
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x87ceeb);

                    // Make scene globally available for environment fog
                    window.presetEditor = { scene: this.scene };

                    // Camera
                    this.camera = new THREE.PerspectiveCamera(75, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 1000);
                    this.camera.position.set(15, 15, 15);
                    this.camera.lookAt(0, 0, 0);

                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                    this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    if (THREE.sRGBEncoding) {
                        this.renderer.outputEncoding = THREE.sRGBEncoding;
                    }

                    // Lights
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                    this.scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(10, 20, 10);
                    directionalLight.castShadow = true;
                    this.scene.add(directionalLight);

                    this.loadingIndicator.style.display = 'none';
                    this.updateStatus('THREE.js initialisiert - Bereit zum Visualisieren');
                    
                    this.animate();

                } catch (error) {
                    console.error('THREE.js Initialisierung fehlgeschlagen:', error);
                    this.showError('THREE.js konnte nicht geladen werden: ' + error.message);
                }
            }

            async renderYAML() {
                const yamlText = this.yamlEditor.value.trim(); if (!yamlText) { this.updateStatus('Kein YAML-Code vorhanden'); return; }
                try {
                    this.updateStatus('Visualisiere YAML...'); 
                    this.resetScene();

                    const worldData = jsyaml.load(yamlText);
                    const spec = resolveWorldSpec(worldData);
                    const rng = Math.random;

                    // 1. Zone OHNE Umgebung bauen (nur Geometrie)
                    const zoneInfo = buildZoneFromSpec(spec, { rng, skipEnvironment: true });
                    this.currentZone = zoneInfo;
                    this.scene.add(this.currentZone.group);

                    // 2. Umgebung (Skybox, Lichter, Nebel) auf die Hauptszene anwenden
                    if (spec.environment) {
                        const { applyEnvironment } = await import('./js/world-generation/environment.js');
                        applyEnvironment(spec.environment, this.scene);
                    }
                    
                    const count = (zoneInfo.objects?.length||0) + (zoneInfo.personas?.length||0) + (zoneInfo.portals?.length||0) + 1;
                    this.updateObjectCount(count);
                    this.updateStatus('‚úÖ YAML erfolgreich visualisiert');
                } catch (error) {
                    console.error('YAML Visualisierung Error:', error);
                    if (error.name === 'YAMLException' && error.message.includes('colon is missed')) this.updateStatus('‚ö†Ô∏è YAML wird getippt... (Doppelpunkt fehlt)');
                    else { this.showError('YAML Fehler: ' + error.message); this.updateStatus('‚ùå YAML Visualisierung fehlgeschlagen'); }
                }
            }

            resetScene() {
                // Entfernt die aktuelle Zone (group) komplett
                if (this.currentZone) {
                    this.scene.remove(this.currentZone.group);
                    this.currentZone.group.traverse(o => {
                        if (o.geometry) o.geometry.dispose();
                        if (o.material) {
                            if (Array.isArray(o.material)) {
                                o.material.forEach(m => m.dispose());
                            } else {
                                o.material.dispose();
                            }
                        }
                    });
                    this.currentZone = null;
                }

                // Entfernt alle Skybox-Objekte aus der Szene
                const skyboxesToRemove = [];
                this.scene.traverse(obj => {
                    if (obj.userData?.isSkybox) {
                        skyboxesToRemove.push(obj);
                    }
                });
                skyboxesToRemove.forEach(skybox => this.scene.remove(skybox));

                // Setzt den Nebel der Szene zur√ºck
                this.scene.fog = null;

                this.updateStatus('Szene zur√ºckgesetzt');
                this.updateObjectCount(0);
            }

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                // Einfache Kamerafahrt f√ºr die Vorschau
                if (this.currentZone) {
                    const time = Date.now() * 0.0005;
                    this.camera.position.x = Math.cos(time) * 20;
                    this.camera.position.z = Math.sin(time) * 20;
                    this.camera.lookAt(0, 0, 0);
                }

                this.renderer.render(this.scene, this.camera);
            }

            // Helper methods
            updateStatus(text) {
                this.statusText.textContent = text;
            }

            updateObjectCount(count) {
                this.objectCount.textContent = `${count} Objekte`;
            }

            showError(message) {
                // Remove existing errors
                const existingError = document.querySelector('.error');
                if (existingError) existingError.remove();

                // Show new error
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.querySelector('.right-panel').appendChild(errorDiv);

                // Auto-remove after 5 seconds
                setTimeout(() => errorDiv.remove(), 5000);
            }

            onMouseDown(event) {
                // Simple camera controls could go here
            }

            onWheel(event) {
                // Zoom control
                event.preventDefault();
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                this.camera.position.multiplyScalar(scale);
            }

            onWindowResize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => { new PresetEditor(); });
    </script>
</body>
</html>
