// Demo-Script f√ºr YAML-basierte Welterstellung
// Zeigt die wichtigsten Funktionen des World Loader Systems

import { WisdomWorld } from './wisdom-world.js';

class YAMLWorldDemo {
  constructor() {
    this.app = null;
  }

  async init() {
    console.log('üåç YAML World Demo startet...');
    
    // Hauptanwendung initialisieren
    this.app = new WisdomWorld();
    
    // KRITISCH: window.app muss auf die WisdomWorld-Instanz zeigen!
    // Der Render-Loop und SimpleZoneManager m√ºssen dieselbe Scene verwenden
    window.app = {
      scene: this.app.scene,           // WisdomWorld Scene
      camera: this.app.threeCamera,    // WisdomWorld Camera 
      renderer: this.app.renderer      // WisdomWorld Renderer
    };
    console.log('‚úÖ window.app verkn√ºpft mit WisdomWorld Scene');
    
    // WICHTIG: ZoneManager MUSS explizit erstellt und zugewiesen werden!
    this.app.zoneManager = new SimpleZoneManager(this.app);
    console.log('‚úÖ ZoneManager erstellt und verkn√ºpft');
    
    // UI-Buttons f√ºr Demo-Funktionen hinzuf√ºgen
    this.addDemoControls();
    
    console.log('‚úÖ Demo bereit! Verwende die Demo-Buttons oder die Konsole.');
  }

  addDemoControls() {
    const demoPanel = document.createElement('div');
    demoPanel.id = 'yaml-demo-panel';
    demoPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      z-index: 1000;
      font-family: monospace;
      font-size: 12px;
      max-width: 300px;
    `;
    
    demoPanel.innerHTML = `
      <h3>üîß YAML World Demo</h3>
      <button id="load-examples">Beispielwelten laden</button><br><br>
      <button id="load-start">Nur Startzone laden</button><br><br>
      <button id="validate-yaml">YAML validieren</button><br><br>
      <button id="show-cache">WorldDoc Cache anzeigen</button><br><br>
      <button id="clear-cache">Cache leeren</button><br><br>
      <small>Siehe auch Browser-Konsole f√ºr Details</small>
    `;
    
    document.body.appendChild(demoPanel);
    
    // Event Listener
    document.getElementById('load-examples').onclick = () => this.loadExamples();
    document.getElementById('load-start').onclick = () => this.loadStartZone();
    document.getElementById('validate-yaml').onclick = () => this.validateAllYAML();
    document.getElementById('show-cache').onclick = () => this.showCache();
    document.getElementById('clear-cache').onclick = () => this.clearCache();
    
    // Konsolen-Funktionen global verf√ºgbar machen
    window.yamlDemo = {
      app: this.app,  // WICHTIG: Referenz auf die WisdomWorld-Instanz
      loadZone: (url) => {
        if (this.app.zoneManager) {
          return this.app.zoneManager.loadFromYAML(url);
        } else if (this.app.loadZoneFromYaml) {
          return this.app.loadZoneFromYaml(url);
        } else {
          throw new Error('Keine loadZone-Methode verf√ºgbar');
        }
      },
      showCache: () => this.showCache(),
      validateYaml: (url) => this.validateSingleYAML(url),
      getWorldDoc: (id) => this.app.zoneManager?.loadedWorldDocs?.get(id),
      listZones: () => Array.from(this.app.zoneManager?.loadedWorldDocs?.keys() || [])
    };
    
    // WICHTIG: Setze zoneManager auch direkt auf yamlDemo
    if (this.app.zoneManager) {
      window.yamlDemo.zoneManager = this.app.zoneManager;
      window.app.zoneManager = this.app.zoneManager;
      console.log('‚úÖ ZoneManager in window.yamlDemo und window.app verf√ºgbar');
    }
    
    console.log('üéÆ Demo-Funktionen verf√ºgbar:');
    console.log('- yamlDemo.loadZone(url) - L√§dt Zone aus URL');
    console.log('- yamlDemo.showCache() - Zeigt geladene WorldDocs');
    console.log('- yamlDemo.validateYaml(url) - Validiert YAML-Datei');
    console.log('- yamlDemo.getWorldDoc(id) - Holt WorldDoc nach ID');
    console.log('- yamlDemo.listZones() - Listet alle Zone-IDs');
  }

  async loadExamples() {
    console.log('üìö Lade alle Beispielwelten...');
    try {
      await this.app.loadExampleWorlds();
      console.log('‚úÖ Alle Beispielwelten geladen!');
      this.showCache();
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Beispielwelten:', error);
    }
  }

  async loadStartZone() {
    console.log('üè† Lade nur Startzone...');
    try {
      await this.app.loadZoneFromYaml('./worlds/zone-start.yaml');
      console.log('‚úÖ Startzone geladen!');
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Startzone:', error);
    }
  }

  async validateAllYAML() {
    console.log('üîç Validiere alle YAML-Dateien...');
    const urls = [
      './worlds/zone-start.yaml',
      './worlds/zone-forest.yaml', 
      './worlds/zone-archive.yaml'
    ];

    for (const url of urls) {
      await this.validateSingleYAML(url);
    }
  }

  async validateSingleYAML(url) {
    try {
      console.log(`üîç Validiere ${url}...`);
      const worldDoc = await this.app.zoneManager.worldLoader.fetchWorldDoc(url);
      const validation = this.app.zoneManager.worldLoader.validateWorldDoc(worldDoc);
      
      if (validation.errors.length === 0) {
        console.log(`‚úÖ ${url} ist g√ºltig!`);
        if (validation.warnings.length > 0) {
          console.warn(`‚ö†Ô∏è  Warnungen f√ºr ${url}:`, validation.warnings);
        }
      } else {
        console.error(`‚ùå Fehler in ${url}:`, validation.errors);
      }
      
      return { worldDoc, validation };
    } catch (error) {
      console.error(`üí• Konnte ${url} nicht laden:`, error);
      return null;
    }
  }

  showCache() {
    const cache = this.app.zoneManager.loadedWorldDocs;
    console.log('üíæ WorldDoc Cache:');
    console.log(`Anzahl geladener Zonen: ${cache.size}`);
    
    cache.forEach((doc, id) => {
      console.log(`üìÑ ${id}:`);
      console.log(`  Name: ${doc.name}`);
      console.log(`  Beschreibung: ${doc.description.substring(0, 50)}...`);
      console.log(`  Objekte: ${doc.objects.length}`);
      console.log(`  Personas: ${doc.personas.length}`);
      console.log(`  Portale: ${doc.portals.length}`);
    });
    
    if (cache.size === 0) {
      console.log('üì≠ Cache ist leer. Lade zuerst einige Zonen.');
    }
  }

  clearCache() {
    console.log('üóëÔ∏è  L√∂sche WorldDoc Cache...');
    this.app.zoneManager.loadedWorldDocs.clear();
    console.log('‚úÖ Cache gel√∂scht!');
  }

  // Hilfsmethode: Beispiel-WorldDoc erstellen
  createExampleWorldDoc() {
    return {
      id: 'demo-zone',
      name: 'Demo Zone',
      description: 'Eine Testzone f√ºr die Demo',
      seed: 12345,
      size: 20,
      environment: {
        sky_color: '#87ceeb',
        ambient_light: 0.7
      },
      objects: [
        {
          type: 'rock',
          position: [5, 0, 0],
          scale: [1, 1, 1],
          color: '#888888',
          text: 'Demo-Stein'
        }
      ],
      personas: [
        {
          name: 'Demo-Guide',
          role: 'Lehrer',
          position: [0, 0, 5],
          dialogue: {
            greeting: 'Willkommen zur Demo!'
          }
        }
      ],
      portals: [
        {
          position: [0, 1, -8],
          destination: 'zone-start',
          color: '#4169e1'
        }
      ]
    };
  }
}

// Simple Zone Manager: baut aus normalisiertem WorldDoc eine Three.js Szene
export class SimpleZoneManager {
    constructor(app) {
        this.app = app || window.app || {};
        this.current = null;
    }

    _ensureApp() {
        // WICHTIG: NIEMALS window.app √ºberschreiben, wenn es bereits existiert!
        // Der Render-Loop in yaml-demo.html referenziert bereits window.app
        if (window.app && window.app.scene && window.app.camera && window.app.renderer) {
            this.app = window.app;
            console.log('‚úÖ Bestehende window.app Instanz wiederverwendet');
            return this.app;
        }
        
        this.app = this.app || window.app || {};
        if (!this.app.scene || !this.app.camera || !this.app.renderer) {
            // Minimal-Setup, falls nicht vorhanden
            const THREE = window.THREE || globalThis.THREE;
            if (!THREE) {
                console.error('‚ùå THREE.js nicht verf√ºgbar!');
                // Fallback-Objekt erstellen
                this.app = {
                    scene: { children: [], add: () => {}, remove: () => {}, background: null },
                    camera: { position: { set: () => {} }, lookAt: () => {} },
                    renderer: { render: () => {} }
                };
                window.app = this.app;
                return this.app;
            }
            
            const canvas = document.getElementById('three');
            if (!canvas) {
                console.error('‚ùå Canvas #three nicht gefunden!');
                // Fallback-Objekt erstellen
                this.app = {
                    scene: { children: [], add: () => {}, remove: () => {}, background: null },
                    camera: { position: { set: () => {} }, lookAt: () => {} },
                    renderer: { render: () => {} }
                };
                window.app = this.app;
                return this.app;
            }
            
            try {
                const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x87ceeb, 1.0); // Himmelblau als Fallback
                
                const scene = new THREE.Scene();
                
                // Basis-Beleuchtung - verst√§rkt f√ºr bessere Sichtbarkeit
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);  // Heller
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);  // St√§rker
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = false;  // Schatten deaktivieren f√ºr Performance
                scene.add(directionalLight);
                
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 8, 12);  // Optimale Position f√ºr Startwiese-Sicht
                camera.lookAt(0, 0, 0);
                
                this.app = { renderer, scene, camera };
                // NUR setzen wenn window.app noch nicht existiert
                if (!window.app) {
                    window.app = this.app;
                }
                
                // Kamera-Steuerung hinzuf√ºgen
                this._setupCameraControls(camera);
                
                // Resize-Handler
                window.addEventListener('resize', () => {
                    const { renderer, camera } = this.app;
                    if (renderer && camera) {
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
                
                console.log('üé® Three.js Setup erstellt');
            } catch (error) {
                console.error('‚ùå Fehler beim Three.js Setup:', error);
                // Fallback-Objekt erstellen
                this.app = {
                    scene: { children: [], add: () => {}, remove: () => {}, background: null },
                    camera: { position: { set: () => {} }, lookAt: () => {} },
                    renderer: { render: () => {} }
                };
                if (!window.app) {
                    window.app = this.app;
                }
            }
        }
        return this.app;
    }

    _setupCameraControls(camera) {
        if (!camera) return;
        
        const keys = { w: false, s: false, a: false, d: false, shift: false, space: false };
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let yaw = 0, pitch = 0;

        // Tastatur-Events
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });

        // Maus-Events
        const canvas = document.getElementById('three');
        if (!canvas) return;

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Linke Maustaste
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isMouseDown = false;
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                yaw -= deltaX * 0.002;
                pitch -= deltaY * 0.002;
                pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });

        // Kamera-Update-Loop
        const updateCamera = () => {
            if (!camera) return;
            
            const moveSpeed = 0.15;
            const position = camera.position;
            
            // Bewegungsrichtungen berechnen
            const forward = new (window.THREE || globalThis.THREE).Vector3(
                Math.sin(yaw), 0, Math.cos(yaw)
            );
            const right = new (window.THREE || globalThis.THREE).Vector3(
                Math.cos(yaw), 0, -Math.sin(yaw)
            );
            
            // Bewegung
            if (keys.w) position.addScaledVector(forward, moveSpeed);
            if (keys.s) position.addScaledVector(forward, -moveSpeed);
            if (keys.d) position.addScaledVector(right, moveSpeed);
            if (keys.a) position.addScaledVector(right, -moveSpeed);
            if (keys.space) position.y += moveSpeed;
            if (keys.shift) position.y -= moveSpeed;
            
            // Kamera-Rotation
            const target = new (window.THREE || globalThis.THREE).Vector3(
                position.x + Math.sin(yaw) * Math.cos(pitch),
                position.y + Math.sin(pitch),
                position.z + Math.cos(yaw) * Math.cos(pitch)
            );
            
            camera.lookAt(target);
            
            requestAnimationFrame(updateCamera);
        };
        
        updateCamera();
        canvas.style.cursor = 'grab';
        console.log('üéÆ Kamera-Steuerung aktiviert: WASD + Maus + Shift/Space');
    }

    _applyEnvironment(doc) {
        const THREE = window.THREE || globalThis.THREE;
        const { scene } = this._ensureApp();
        
        if (!THREE || !scene || !scene.add) {
            console.warn('‚ö†Ô∏è THREE.js oder Scene nicht verf√ºgbar, Environment wird √ºbersprungen');
            return;
        }
        
        try {
            if (doc.sky_color && scene.background !== undefined) {
                scene.background = new THREE.Color(doc.sky_color);
            }
            if (doc.ambient_light != null) {
                const amb = new THREE.AmbientLight(0xffffff, Number(doc.ambient_light) || 0.5);
                scene.add(amb);
            }
            if (doc.sun_intensity != null) {
                const dir = new THREE.DirectionalLight(0xffffff, Number(doc.sun_intensity) || 1.0);
                const p = doc.sun_position || [10, 20, 10];
                dir.position.set(p[0], p[1], p[2]);
                scene.add(dir);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Environment-Setup fehlgeschlagen:', error);
        }
    }

    _buildTerrain(doc) {
        const THREE = window.THREE || globalThis.THREE;
        const { scene } = this._ensureApp();
        
        if (!THREE || !scene || !scene.add) {
            console.warn('‚ö†Ô∏è THREE.js oder Scene nicht verf√ºgbar, Terrain wird √ºbersprungen');
            return null;
        }
        
        try {
            const size = doc.size || 20;  // Standardgr√∂√üe beibehalten
            const color = doc.terrain?.base_color || '#228b22';  // Gr√ºneres Gras
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size, 8, 8),  // Mehr Segmente f√ºr bessere Sichtbarkeit
                new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness: 0.8, 
                    metalness: 0.0,
                    emissive: new THREE.Color(color).multiplyScalar(0.15), // Deutlich sichtbarer
                    wireframe: false
                })
            );
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;  // Leicht unter Null f√ºr bessere Sichtbarkeit
            scene.add(plane);
            console.log(`üåç Terrain erstellt: ${size}x${size} Einheiten bei y=-0.1`);
            return plane;
        } catch (error) {
            console.warn('‚ö†Ô∏è Terrain-Erstellung fehlgeschlagen:', error);
            return null;
        }
    }

    _buildObjects(doc) {
        const THREE = window.THREE || globalThis.THREE;
        const { scene } = this._ensureApp();
        
        if (!THREE || !scene || !scene.add) {
            console.warn('‚ö†Ô∏è THREE.js oder Scene nicht verf√ºgbar, Objekte werden √ºbersprungen');
            return [];
        }
        
        const built = [];
        try {
            for (const o of (doc.objects || [])) {
                let mesh = null;
                const color = o.color || '#cccccc';
                const mat = new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness: 0.7, 
                    metalness: 0.1,
                    emissive: new THREE.Color(color).multiplyScalar(0.1) // Leichtes Gl√ºhen
                });
                switch ((o.type || 'rock').toLowerCase()) {
                    case 'tree': {
                        const trunkMat = new THREE.MeshStandardMaterial({ 
                            color: '#8b5a2b', 
                            roughness: 0.9, 
                            metalness: 0.0,
                            emissive: new THREE.Color('#8b5a2b').multiplyScalar(0.05)
                        });
                        const crownMat = new THREE.MeshStandardMaterial({ 
                            color: '#228b22', 
                            roughness: 0.8, 
                            metalness: 0.0,
                            emissive: new THREE.Color('#228b22').multiplyScalar(0.1)
                        });
                        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 2, 8), trunkMat);
                        trunk.position.set(0, 1, 0);
                        const crown = new THREE.Mesh(new THREE.SphereGeometry(1.0, 12, 12), crownMat);
                        crown.position.set(0, 2.2, 0);
                        mesh = new THREE.Group();
                        mesh.add(trunk);
                        mesh.add(crown);
                        break;
                    }
                    case 'crystal': {
                        const crystalMat = new THREE.MeshStandardMaterial({ 
                            color: '#88ccff', 
                            roughness: 0.1, 
                            metalness: 0.8,
                            emissive: new THREE.Color('#88ccff').multiplyScalar(0.3) // Kristall gl√ºht
                        });
                        mesh = new THREE.Mesh(new THREE.OctahedronGeometry(1), crystalMat);
                        break;
                    }
                    case 'rock':
                    default: {
                        mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(1), mat);
                        break;
                    }
                }
                const p = o.position || [0, 0, 0];
                const s = o.scale || [1, 1, 1];
                mesh.position.set(p[0], p[1], p[2]);
                mesh.scale.set(s[0], s[1], s[2]);
                scene.add(mesh);
                built.push(mesh);
                console.log(`üéØ Objekt ${o.type || 'rock'} erstellt bei [${p.join(', ')}] mit Skalierung [${s.join(', ')}]`);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Objekt-Erstellung fehlgeschlagen:', error);
        }
        return built;
    }

    _buildMarkers(list, color) {
        const THREE = window.THREE || globalThis.THREE;
        const { scene } = this._ensureApp();
        
        if (!THREE || !scene || !scene.add) {
            console.warn('‚ö†Ô∏è THREE.js oder Scene nicht verf√ºgbar, Marker werden √ºbersprungen');
            return [];
        }
        
        const built = [];
        try {
            for (const it of (list || [])) {
                const mesh = new THREE.Mesh(
                    new THREE.TorusGeometry(0.7, 0.15, 8, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: color || '#66ddff',
                        roughness: 0.3,
                        metalness: 0.5,
                        emissive: new THREE.Color(color || '#66ddff').multiplyScalar(0.2) // Marker gl√ºhen
                    })
                );
                const p = it.position || [0, 0.1, 0];
                mesh.position.set(p[0], p[1], p[2]);
                mesh.rotation.x = -Math.PI / 2;
                scene.add(mesh);
                built.push(mesh);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Marker-Erstellung fehlgeschlagen:', error);
        }
        return built;
    }

    async loadFromYAML(url) {
        // expects normalizeWorldDoc on window
        const res = await fetch(url, { cache: 'no-cache' });
        const text = await res.text();
        const parsed = (await import('js-yaml')).load(text);
        const doc = (parsed?.worldDoc ?? parsed) || {};
        const normalized = (window.normalizeWorldDoc || ((d)=>d))(doc);
        return this.createZoneFromDoc(normalized);
    }

    async createZoneFromDoc(doc) {
        const { scene, camera } = this._ensureApp();
        
        // Sichere √úberpr√ºfung der Scene
        if (!scene || !scene.children) {
            console.warn('‚ö†Ô∏è Scene nicht verf√ºgbar, erstelle minimale Fallback-Zone');
            this.current = { doc, terrain: null, objects: [], portals: [], personas: [] };
            return this.current;
        }
        
        // Clear scene completely
        try {
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            console.log('üßπ Szene komplett geleert');
        } catch (error) {
            console.warn('‚ö†Ô∏è Scene clearing fehlgeschlagen:', error);
        }

        this._applyEnvironment(doc);
        const terrain = this._buildTerrain(doc);
        const objects = this._buildObjects(doc);
        const portals = this._buildMarkers(doc.portals, '#ffcc66');
        const personas = this._buildMarkers(doc.personas, '#dd66ff');

        // UI-Avatar wird vom yaml-demo.html System verwaltet, nicht hier
        console.log('üö∂ Player Avatar wird vom bestehenden UI-System verwaltet');

        // Debug: Zentrum-Marker und Orientierungshilfen hinzuf√ºgen
        try {
            const THREE = window.THREE || globalThis.THREE;
            if (THREE && scene && scene.add) {
                // Zentrum-Marker (rote Kugel)
                const centerMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: '#ff0000' })
                );
                centerMarker.position.set(0, 0.2, 0);
                scene.add(centerMarker);
                
                // Orientierungshilfen - farbige Achsen
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);
                
                // Orientierungskubus n√§her f√ºr bessere Sichtbarkeit
                const orientationCubes = [
                    { pos: [6, 2, 0], color: '#ff4444', label: 'Osten (+X)' },
                    { pos: [-6, 2, 0], color: '#44ff44', label: 'Westen (-X)' },
                    { pos: [0, 2, 6], color: '#4444ff', label: 'S√ºden (+Z)' },
                    { pos: [0, 2, -6], color: '#ffff44', label: 'Norden (-Z)' }
                ];
                
                orientationCubes.forEach(({ pos, color, label }) => {
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 4, 2),  // Noch gr√∂√üer f√ºr maximale Sichtbarkeit
                        new THREE.MeshStandardMaterial({ 
                            color,
                            emissive: new THREE.Color(color).multiplyScalar(0.5),  // Sehr hell
                            roughness: 0.2,
                            metalness: 0.3
                        })
                    );
                    cube.position.set(pos[0], pos[1], pos[2]);
                    scene.add(cube);
                });
                
                console.log('üéØ Orientierungshilfen hinzugef√ºgt: Zentrum-Marker, Achsen und Richtungskubus');
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Orientierungshilfen Fehler:', error);
        }

        // Reset camera mit optimaler Position f√ºr sichtbare Startwiese
        try {
            if (camera && camera.position && camera.position.set) {
                camera.position.set(0, 8, 12);  // H√∂her f√ºr bessere Sicht auf alle Objekte
            }
            if (camera && camera.lookAt) {
                camera.lookAt(0, 0, 0);  // Auf den Ursprung schauen
            }
            console.log('üì∑ Kamera positioniert bei [0, 8, 12] mit Blick auf [0, 0, 0] f√ºr optimale Startwiese-Sicht');
        } catch (error) {
            console.warn('‚ö†Ô∏è Camera reset fehlgeschlagen:', error);
        }

        this.current = { doc, terrain, objects, portals, personas };
        console.log('‚úÖ Zone aus WorldDoc erstellt:', {
            name: doc.name || 'Unbenannt',
            objects: objects.length,
            portals: portals.length,
            personas: personas.length
        });
        return this.current;
    }
}

// Auto-register if window available
try {
    if (typeof window !== 'undefined') {
        // Nur setzen, wenn nicht bereits vorhanden
        if (!window.SimpleZoneManager) {
            window.SimpleZoneManager = SimpleZoneManager;
        }
        window.yamlDemo = window.yamlDemo || {};
        window.app = window.app || {};
        
        // KRITISCH: zoneManager MUSS verf√ºgbar sein f√ºr yaml-demo.html
        if (!window.app.zoneManager) {
            const zm = new SimpleZoneManager(window.app);
            window.app.zoneManager = zm;
            window.yamlDemo.zoneManager = zm;
            console.log('‚úÖ ZoneManager auto-registriert f√ºr window.app und window.yamlDemo');
        }
        
        // Warte auf WisdomWorld und verkn√ºpfe dann richtig
        if (window.WisdomWorld) {
            setTimeout(() => {
                // Pr√ºfe ob yamlDemo bereits eine Instanz hat
                if (window.yamlDemo.app && window.yamlDemo.app.zoneManager) {
                    window.app.zoneManager = window.yamlDemo.app.zoneManager;
                    console.log('‚úÖ ZoneManager von yamlDemo.app √ºbernommen');
                }
            }, 100);
        }
    }
} catch (e) {
    console.warn('Auto-register Warnung:', e);
}

// Sammle Exporte einmalig
export { YAMLWorldDemo };
