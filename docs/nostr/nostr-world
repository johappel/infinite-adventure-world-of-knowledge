### **Konzept: "NostrWorld" – Ein dezentraler 3D-Welt-Client**

#### 1. Kernphilosophie
*   **Kein zentraler Server:** Der Client agiert serverless. Alle persistenten Daten und Echtzeit-Interaktionen werden über ein dezentrales Netz von Nostr-Relays abgewickelt.
*   **Benutzer-Souveränität:** Jeder Spieler ist durch seinen Nostr-Schlüssel Herr seiner eigenen Identität und seiner Aktionen. Aktionen sind kryptografisch signiert und nachweisbar.
*   **Zusammensetzbarkeit und Offenheit:** Jede Welt ist ein offener Daten-Feed. Andere können eigene Clients bauen, die dieselbe Welt lesen, oder die Welt "forken" und ihre eigene Version erschaffen.

---

#### 2. Das Datenmodell: Die "NostrWorld"-Protokoll-Events

Wir definieren einen Satz von `kind`-Nummern, die das Protokoll für unsere Anwendung bilden.

| `kind` | Name | Typ | Zweck |
| :--- | :--- | :--- | :--- |
| **`30311`** | **Genesis-Event** | Persistent | Definiert die Existenz und die Grundregeln einer Welt. Dient als Wurzel für alle anderen Daten. |
| **`30312`** | **Patch-Event** | Persistent | Beschreibt eine einzelne, atomare Änderung an der Welt (`create`, `update`, `delete`). |
| **`30313`** | **Chat-Event** | Persistent | Eine einzelne, persistente Chat-Nachricht innerhalb einer Welt. |
| **`27777`** | **Movement-Event**| Ephemer | Hochfrequente, flüchtige Positions- und Zustandsdaten eines Spielers. |
| **`0`** | **Profile-Event** | Persistent | Standard-Nostr-Event, das zum Abrufen von Spielernamen und -bildern verwendet wird. |

---

#### 3. Client-Lebenszyklus: Vom Start bis zur interaktiven Welt

Dies sind die Schritte, die der Client beim Start ausführt:

1.  **Initialisierung & Identität:**
    *   Der Client startet.
    *   Er fragt den Benutzer nach seinem Nostr-Privatschlüssel (`nsec...`) oder generiert ein neues Schlüsselpaar.
    *   Er verbindet sich mit einer vom Benutzer konfigurierten Liste von Nostr-Relays.

2.  **Auswahl der Welt:**
    *   Der Benutzer gibt die Adresse einer Welt ein. Die eleganteste Form hierfür ist eine Nostr-Adresse (`naddr`).
    *   Beispiel: `naddr1qq...` die auf das Genesis-Event der Welt verweist.

3.  **Laden der Basis-Welt (Schritt 1):**
    *   Der Client fragt die Relays nach dem einen **Genesis-Event (`kind: 30311`)**, das durch die `naddr` identifiziert wird.
    *   Der `content` dieses Events enthält die grundlegende YAML-Konfiguration. Diese wird geparst.
    *   Der Three.js-Renderer wird initialisiert und baut die statische und prozedurale Geometrie auf (Landschaft, Himmel, prozedurale Wälder ohne IDs usw.).
    *   **Ergebnis:** Der Spieler sieht die statische, leblose Welt.

4.  **Laden der persistenten Änderungen (Schritt 2):**
    *   Der Client fragt die Relays nach **allen Patch-Events (`kind: 30312`)**, die auf das Genesis-Event verweisen (über einen `a`-Tag: `["a", "30311:PUBKEY_DES_ERSTELLERS:WELT_ID"]`).
    *   Der Client sortiert die empfangenen Patch-Events chronologisch nach ihrem `created_at`-Zeitstempel.
    *   Er iteriert durch die sortierte Liste und wendet jeden Patch nacheinander auf die Welt an: Er erschafft, aktualisiert oder löscht Entitäten in der Three.js-Szene.
    *   **Ergebnis:** Die Welt ist nun im aktuellsten persistenten Zustand. Alle von Spielern gebauten Strukturen sind sichtbar.

5.  **Eintritt in die Echtzeit-Sitzung (Schritt 3):**
    *   Der Client erstellt nun **drei permanente Abonnements** bei den Relays, die alle auf den `a`-Tag der Welt gefiltert sind:
        1.  Ein Abo für zukünftige **Patch-Events (`kind: 30312`)**, um live mitzubekommen, wenn jemand etwas baut.
        2.  Ein Abo für **Movement-Events (`kind: 27777`)**, um andere Spieler zu sehen.
        3.  Ein Abo für **Chat-Events (`kind: 30313`)**, um die Kommunikation zu empfangen.
    *   Gleichzeitig beginnt der Client selbst, in kurzen Intervallen (z.B. 10 Mal pro Sekunde) seine eigenen **Movement-Events (`kind: 27777`)** zu senden.
    *   **Ergebnis:** Der Spieler ist vollständig in der Welt. Er sieht andere Spieler, kann mit ihnen chatten und zusehen, wie die Welt live verändert wird.

---

#### 4. Handhabung von Interaktionen

*   **Andere Spieler bewegen sich:** Wenn ein `Movement-Event` vom Abo empfangen wird, sucht der Client den Avatar, der zum Public Key des Events gehört, und aktualisiert dessen Position/Rotation in der Three.js-Szene. (Idealerweise mit sanfter Interpolation, um Ruckeln zu vermeiden).
*   **Ein Spieler baut etwas:** Der Spieler führt im Client eine Aktion aus (z.B. "Platziere Block"). Der Client generiert ein **Patch-Event (`kind: 30312`)** mit `action: "create"`, signiert es und sendet es ab. Da der Client sein eigenes Abo hat, empfängt er sein eigenes Event zurück und rendert die Änderung, genau wie alle anderen auch.
*   **Ein Spieler chattet:** Der Spieler tippt eine Nachricht ein. Der Client erstellt ein **Chat-Event (`kind: 30313`)**, signiert es und sendet es ab. Das Event erscheint bei allen im Chatfenster.

---

#### 5. Fortgeschrittene Konzepte und Lösungen

*   **Moderation und Kanon:**
    *   **Problem:** Was ist die "offizielle" Welt, wenn jeder Forks erstellen kann?
    *   **Lösung:** Der Client kann eine "Maintainer-Kette" bevorzugen. Er prüft, welche Kette von Patches durchgehend vom Public Key des ursprünglichen Welterstellers signiert ist. Dies wird als die "kanonische" Version der Welt angezeigt. Änderungen von anderen werden als "Vorschläge" oder "Forks" behandelt.

*   **Performance & Skalierbarkeit:**
    *   **Problem:** Eine Welt mit 100.000 Patches würde das Laden extrem verlangsamen.
    *   **Lösung: Snapshotting.** Der Welten-Maintainer kann periodisch ein neues **Genesis-Event (Version 2)** erstellen. Der YAML-Inhalt dieses neuen Events ist der Zustand der Welt *nach* Anwendung aller bisherigen Patches. Dieses neue Genesis-Event verweist auf sein Vorgänger-Event. Neue Spieler müssen dann nur den neuesten Snapshot laden und die wenigen Patches, die seitdem erstellt wurden.

*   **Asset-Management:**
    *   3D-Modelle (`.gltf`), Texturen und Sounds werden nicht auf Nostr gespeichert.
    *   Die YAML-Datei in der Welt-Definition verweist auf diese Assets über URLs (z.B. zu einem IPFS-Gateway oder einer einfachen Webseite/CDN). Der Client ist dafür verantwortlich, diese Assets beim Laden herunterzuladen.



## Lokale Datenhaltung und Entwicklung mit IndexDB

Wir müssen sicherstellen, dass beide Systeme – Dexie und ein Nostr-Relay – die exakt gleiche "Sprache" sprechen. Diese Sprache besteht aus zwei Teilen: **Events** und **Filtern**.

Die Lösung ist, eine eigene "Adapter"-Schnittstelle zu definieren. Ihr Anwendungs-Code wird ausschließlich mit dieser Schnittstelle sprechen. Wir erstellen dann zwei verschiedene Implementierungen dieser Schnittstelle: eine für Dexie und eine für echte Relays.

### Die goldene Regel: Ihr Anwendungscode sollte niemals wissen, mit wem er spricht.

---

### Schritt 1: Definieren der einheitlichen Schnittstelle (`INostrService`)

Wir legen fest, welche Aktionen unser "Nostr-Dienst" können muss. In TypeScript würde man das als `interface` schreiben, aber das Konzept ist in JavaScript das gleiche:

```javascript
// Dies ist nur eine konzeptionelle Definition.

interface INostrService {
  /**
   * Veröffentlicht ein einzelnes Event.
   * @param {Event} event - Das zu veröffentlichende, signierte Nostr-Event.
   * @returns {Promise<void>}
   */
  publish(event);

  /**
   * Abonniert einen Stream von Events, die einem Filter entsprechen.
   * Gibt einen asynchronen Iterator zurück, der Events liefert, sobald sie eintreffen.
   * @param {Filter} filter - Ein einzelner Nostr-Filter.
   * @returns {AsyncIterable<Event>}
   */
  subscribe(filter);

  /**
   * Holt einen Satz von Events, die einem Filter entsprechen, und schließt dann die Verbindung.
   * @param {Filter} filter - Ein einzelner Nostr-Filter.
   * @returns {Promise<Event[]>}
   */
  get(filter);
  
  /**
   * Beendet ein Abonnement.
   * @param {Subscription} subscription - Das zurückgegebene Objekt von subscribe().
   */
  unsubscribe(subscription);
}
```

---

### Schritt 2: Implementierung Nr. 1 – `DexieNostrService`

Diese Klasse implementiert unsere `INostrService`-Schnittstelle und verwendet Dexie.js im Hintergrund.

**1. Datenbank-Setup (mit Dexie):**

```javascript
import Dexie from 'dexie';

const db = new Dexie('NostrLocalDatabase');
db.version(1).stores({
  // Ein sehr effizienter Store für unsere Events.
  // "++id" ist ein Auto-Incrementing Primary Key für Dexie.
  // Die anderen sind die Indizes, die wir zum Filtern brauchen.
  // "&eventId" bedeutet, die Event-ID muss einzigartig sein.
  events: '++id, &eventId, pubkey, kind, created_at, *tags'
});
```
*   `*tags` ist ein Multi-Entry-Index. Dexie kann damit extrem schnell nach Events suchen, die ein bestimmtes Tag enthalten (z.B. `['a', '30311:...']`).

**2. Die `DexieNostrService`-Klasse:**

```javascript
class DexieNostrService {
  constructor(dexieDb) {
    this.db = dexieDb;
    // Ein einfacher Event-Emitter, um Live-Updates zu simulieren
    this.liveSubscriptions = new Map(); 
  }

  async publish(event) {
    // 1. Nicht speichern, wenn es ephemer ist
    if (event.kind >= 20000 && event.kind < 30000) {
      // Aber Live-Abonnenten trotzdem benachrichtigen!
      this._notifySubscribers(event);
      return;
    }

    // 2. In die Datenbank schreiben
    try {
      await this.db.events.add({
        eventId: event.id,
        pubkey: event.pubkey,
        kind: event.kind,
        created_at: event.created_at,
        content: event.content,
        sig: event.sig,
        tags: event.tags.map(t => `${t[0]}:${t[1] || ''}`) // Tags für die Suche formatieren
      });
    } catch (e) {
      // Ignoriere Fehler bei doppelten Events
    }
    
    // 3. Live-Abonnenten benachrichtigen
    this._notifySubscribers(event);
  }

  async* subscribe(filter) {
    // 1. Hole alle historischen Events, die dem Filter entsprechen
    let historicalEvents = await this._query(filter).toArray();
    for (const event of historicalEvents) {
      yield this._dbToNostrEvent(event); // Gib historische Events sofort zurück
    }

    // 2. Richte ein Live-Abonnement für zukünftige Events ein
    const subId = crypto.randomUUID();
    const queue = [];
    let resolve;

    this.liveSubscriptions.set(subId, (event) => {
        if (this._matches(event, filter)) {
            if (resolve) {
                resolve({ value: event, done: false });
                resolve = null;
            } else {
                queue.push(event);
            }
        }
    });

    try {
        while (true) {
            if (queue.length > 0) {
                yield queue.shift();
            } else {
                yield new Promise(r => resolve = r);
            }
        }
    } finally {
        this.liveSubscriptions.delete(subId); // Aufräumen, wenn die Schleife beendet wird
    }
  }

  // Hilfsmethoden zum Suchen (`_query`), Matchen (`_matches`) und Konvertieren (`_dbToNostrEvent`)
  // ...
}
```

Die Logik hier ist: `subscribe` gibt zuerst alle passenden Events aus der Datenbank zurück und wartet dann auf neue Events, die durch `publish` ausgelöst und über den internen Emitter verteilt werden. Das simuliert das Verhalten eines Relays perfekt.

---

### Schritt 3: Implementierung Nr. 2 – `RelayNostrService`

Diese Klasse implementiert dieselbe Schnittstelle, verwendet aber eine echte Nostr-Bibliothek wie `nostr-tools`.

```javascript
import { SimplePool } from 'nostr-tools';

class RelayNostrService {
  constructor(relayUrls) {
    this.pool = new SimplePool();
    this.relays = relayUrls;
  }

  async publish(event) {
    await this.pool.publish(this.relays, event);
  }

  async* subscribe(filter) {
    const sub = this.pool.sub(this.relays, [filter]);
    const queue = [];
    let resolve;

    sub.on('event', (event) => {
      if (resolve) {
        resolve({ value: event, done: false });
        resolve = null;
      } else {
        queue.push(event);
      }
    });

    // Wichtig: nostr-tools `sub` gibt historische und live Events im selben Stream aus.
    // Die Logik ist also einfacher als bei der Dexie-Version.
    try {
      while (true) {
        if (queue.length > 0) {
          yield queue.shift();
        } else {
          yield new Promise(r => resolve = r);
        }
      }
    } finally {
      sub.unsub(); // Aufräumen!
    }
  }
}
```

---

### Schritt 4: Alles im Haupt-Code zusammenführen

Jetzt ist der Code Ihrer Anwendung wunderbar sauber. Sie entscheiden nur einmal am Anfang, welche Implementierung geladen wird.

**config.js:**
```javascript
export const APP_MODE = 'development'; // 'development' oder 'production'
export const RELAYS = ['wss://relay.damus.io', 'wss://nostr.wine'];
```

**nostr-service-factory.js:**
```javascript
import { DexieNostrService } from './dexie-nostr-service.js';
import { RelayNostrService } from './relay-nostr-service.js';
import { APP_MODE, RELAYS } from './config.js';

let serviceInstance;

if (APP_MODE === 'development') {
  serviceInstance = new DexieNostrService(/* ... dexie db instance ... */);
  console.log("Nostr Service: Running in local Dexie mode.");
} else {
  serviceInstance = new RelayNostrService(RELAYS);
  console.log("Nostr Service: Running in live Relay mode.");
}

export const nostrService = serviceInstance;
```

**Ihre Anwendung (z.B. world-loader.js):**
```javascript
import { nostrService } from './nostr-service-factory.js';

async function loadWorld(worldAddress) {
  // Egal welcher Modus, der Code ist IDENTISCH!
  const subscription = nostrService.subscribe({ 'authors': [worldAddress.pubkey], 'kinds': [30312] });

  for await (const patchEvent of subscription) {
    // wende Patch an...
    console.log('Received patch event:', patchEvent.id);
  }
}
```