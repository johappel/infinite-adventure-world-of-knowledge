<!DOCTYPE html>
<html>
<head>
    <title>Three.js Running Avatar - Key Control</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

        // Szene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Kamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 7); // Angepasste Kameraposition

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Licht
        const light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 20, 0);
        scene.add(light);

        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(0, 20, 10);
        scene.add(directionalLight);

        // Materialien
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });

        // Avatar Gruppe
        const avatar = new THREE.Group();
        scene.add(avatar);
        camera.lookAt(avatar.position); // Kamera schaut auf den Avatar

        // Rumpf
        const torsoGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
        const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
        avatar.add(torso);

        // Kopf
        const headGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.position.y = 1.2;
        avatar.add(head);

        // Linker Arm
        const leftArmGroup = new THREE.Group();
        leftArmGroup.position.set(0.75, 0.5, 0);
        avatar.add(leftArmGroup);

        const leftArmGeometry = new THREE.BoxGeometry(0.25, 1, 0.25);
        const leftArm = new THREE.Mesh(leftArmGeometry, bodyMaterial);
        leftArm.position.y = -0.5;
        leftArmGroup.add(leftArm);

        // Rechter Arm
        const rightArmGroup = new THREE.Group();
        rightArmGroup.position.set(-0.75, 0.5, 0);
        avatar.add(rightArmGroup);
        
        const rightArm = new THREE.Mesh(leftArmGeometry, bodyMaterial);
        rightArm.position.y = -0.5;
        rightArmGroup.add(rightArm);

        // Linkes Bein
        const leftLegGroup = new THREE.Group();
        leftLegGroup.position.set(0.3, -0.75, 0);
        avatar.add(leftLegGroup);

        const leftLegGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);
        const leftLeg = new THREE.Mesh(leftLegGeometry, bodyMaterial);
        leftLeg.position.y = -0.6;
        leftLegGroup.add(leftLeg);

        // Rechtes Bein
        const rightLegGroup = new THREE.Group();
        rightLegGroup.position.set(-0.3, -0.75, 0);
        avatar.add(rightLegGroup);

        const rightLeg = new THREE.Mesh(leftLegGeometry, bodyMaterial);
        rightLeg.position.y = -0.6;
        rightLegGroup.add(rightLeg);

        const clock = new THREE.Clock();
        let isAnimating = false;

        window.addEventListener('keydown', (event) => {
            if (event.key === 'w' || event.key === 's') {
                isAnimating = true;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'w' || event.key === 's') {
                isAnimating = false;
            }
        });

        function animate() {
            requestAnimationFrame(animate);

            if (isAnimating) {
                const elapsedTime = clock.getElapsedTime();

                // Laufanimation
                const runSpeed = 10;
                const swingAngle = Math.PI / 4;

                leftArmGroup.rotation.x = Math.sin(elapsedTime * runSpeed) * swingAngle;
                rightArmGroup.rotation.x = -Math.sin(elapsedTime * runSpeed) * swingAngle;

                leftLegGroup.rotation.x = -Math.sin(elapsedTime * runSpeed) * swingAngle;
                rightLegGroup.rotation.x = Math.sin(elapsedTime * runSpeed) * swingAngle;
            } else {
                // Zur√ºcksetzen in die Ausgangsposition
                leftArmGroup.rotation.x = 0;
                rightArmGroup.rotation.x = 0;
                leftLegGroup.rotation.x = 0;
                rightLegGroup.rotation.x = 0;
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>